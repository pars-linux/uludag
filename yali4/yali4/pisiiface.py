# -*- coding: utf-8 -*-
#
# Copyright (C) 2005-2008, TUBITAK/UEKAE
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version.
#
# Please read the COPYING file.
#

# PiSÄ° module for YALI

import os
import time
import glob
import dbus
import pisi
import yali4.postinstall
import yali4.sysutils
from yali4.constants import consts

repodb = pisi.db.repodb.RepoDB()

def initialize(ui, with_comar = False, nodestDir = False):
    options = pisi.config.Options()
    import yali4.gui.context as ctx
    ctx.debugger.log("Pisi initializing..")
    if not nodestDir:
        options.destdir = consts.target_dir
    options.yes_all = True
    options.ignore_dependency = True
    options.ignore_safety = True
    # wait for chroot_dbus to initialize
    # generally we don't need this but I think this is safer
    for i in range(20):
        try:
            ctx.debugger.log("DBUS call..")
            bus = dbus.SystemBus()
            break
        except dbus.DBusException:
            time.sleep(1)
    pisi.api.set_dbus_sockname("%s/var/run/dbus/system_bus_socket" % options.destdir)

    try:
        pisi.api.set_dbus_timeout(1200)
    except AttributeError, e:
        # An old pisi running on disc, forget the dbus
        pass

    pisi.api.set_userinterface(ui)
    pisi.api.set_options(options)
    pisi.api.set_comar(with_comar)
    pisi.api.set_signal_handling(False)

def add_repo(name=None, uri=None):
    if name and uri:
        pisi.api.add_repo(name, uri)

def add_cd_repo():
    cd_repo_name = consts.cd_repo_name
    cd_repo_uri = consts.cd_repo_uri
    if not repodb.has_repo(cd_repo_name):
        add_repo(cd_repo_name, cd_repo_uri)
        update_repo(cd_repo_name)

def add_remote_repo(name, uri):
    if not repodb.has_repo(name):
        add_repo(name, uri)
        update_repo(name)

def switch_to_pardus_repo():
    cd_repo_name = consts.cd_repo_name
    pardus_repo_name = consts.pardus_repo_name
    pardus_repo_uri = consts.pardus_repo_uri

    remove_repo(cd_repo_name)
    add_repo(pardus_repo_name, pardus_repo_uri)

def update_repo(name):
    pisi.api.update_repo(consts.cd_repo_name)

def remove_repo(name):
    pisi.api.remove_repo(name)

def take_back(operation):
    # dirty hack for COMAR to find scripts.
    os.symlink("/",consts.target_dir + consts.target_dir)
    pisi.api.takeback(operation)
    os.unlink(consts.target_dir + consts.target_dir)

def getExtraLangs():

    def getPackages(piksemelObj, isa):
        ret = []
        for package in piksemelObj.tags("Package"):
            tagData = package.getTagData("IsA")
            if tagData:
                for node in package.tags("IsA"):
                    data = node.firstChild().data()
                    if data.startswith(isa) and not data.find(':') == -1:
                        ret.append("%s,%s" % (package.getTagData("PackageURI"), data.split(':')[1]))
        return ret

    import piksemel
    import bz2

    index_path = os.path.join(consts.source_dir, "repo/pisi-index.xml.bz2")
    index = piksemel.parseString(bz2.decompress(file(index_path).read()))

    return getPackages(index, "locale")

def get_not_needed_langs():
    return map(lambda x: os.path.join(consts.source_dir, 'repo', x.split(',')[0]), \
        filter(lambda x: not x.split(',')[1].startswith((consts.lang, "en")), getExtraLangs()))

def getHistory(limit=50):
    pdb = pisi.db.historydb.HistoryDB()
    result = []
    i=0
    for op in pdb.get_last():
        result.append(op)
        i+=1
        if i==limit:
            break
    return result

def finalize():
    pass

def install(pkg_name_list):
    pisi.api.install(pkg_name_list)

def install_all():
    install(get_available())

def get_all_with_paths(use_sort_file=False):
    packages = []

    if use_sort_file and os.path.exists("%s/repo/install.order" % consts.source_dir):
        # Read the installation order from the sort_list generated by pardusman
        # baselayout is explicitly moved to the top of the list in pardusman
        for package in [l.split(" ")[0] for l in open("%s/repo/install.order" % consts.source_dir, "r").readlines() if l]:
            packages.append(os.path.join(consts.source_dir, "repo", os.path.basename(package)))

    else:
        # Get packages with their full paths
        packages = glob.glob('%s/repo/*.pisi' % consts.source_dir)

        # Make baselayout package first
        baselayout = None
        for package in packages:
            if 'baselayout' in package:
                baselayout = packages.index(package)
                break

        if baselayout:
            packages.insert(0, packages.pop(baselayout))

    return packages

def get_available():
    return pisi.api.list_available()

def get_available_len():
    return len(get_available())

def get_pending():
    return pisi.db.installdb.InstallDB().list_pending()

def get_install_order(pkg_name_list):
    return pisi.api.get_install_order(pkg_name_list)

def get_pending_len():
    return len(get_pending())

def configure_pending():
    # dirty hack for COMAR to find scripts.
    os.symlink("/",consts.target_dir + consts.target_dir)
    # Make baselayout configure first
    pisi.api.configure_pending(['baselayout'])
    # And all of pending packages
    pisi.api.configure_pending()
    os.unlink(consts.target_dir + consts.target_dir)

def check_package_hash(pkg_name):
    repo_path = os.path.dirname(consts.cd_repo_uri)

    pkg = pisi.db.packagedb.PackageDB().get_package(pkg_name)
    file_name = pisi.util.package_name(pkg.name,
                                       pkg.version,
                                       pkg.release,
                                       pkg.build)
    file_hash = pisi.util.sha1_file(
        os.path.join(repo_path, file_name))

    if not pkg.packageHash == file_hash:
        raise Exception

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>dbus-qt3-backport: QDBusProxy Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>QDBusProxy Class Reference</h1><!-- doxytag: class="QDBusProxy" -->Client interface to a remote service object.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="qdbusproxy_8h-source.html">qdbusproxy.h</a>&gt;</code>
<p>

<p>
<a href="classQDBusProxy-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Signals</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#6da8694c00848352284f08d0a6f232a9">dbusSignal</a> (const <a class="el" href="classQDBusMessage.html">QDBusMessage</a> &amp;message)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal emitted for DBus signals from the peer.  <a href="#6da8694c00848352284f08d0a6f232a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#884668d72219475bf0378e7e73c74c40">asyncReply</a> (int callID, const <a class="el" href="classQDBusMessage.html">QDBusMessage</a> &amp;message)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal emitted for received replies to asynchronous method calls.  <a href="#884668d72219475bf0378e7e73c74c40"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#135144b31c4615667503f75d93347cc0">QDBusProxy</a> (QObject *parent=0, const char *name=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a proxy without binding it to a service or connection.  <a href="#135144b31c4615667503f75d93347cc0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#c4d39333bc9908bc196dac8887123b48">QDBusProxy</a> (const <a class="el" href="classQDBusConnection.html">QDBusConnection</a> &amp;connection, QObject *parent=0, const char *name=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a proxy on a given connection without binding it to a service.  <a href="#c4d39333bc9908bc196dac8887123b48"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#fac50752f3b0f70d731940257fb60d49">QDBusProxy</a> (const QString &amp;service, const QString &amp;path, const QString &amp;interface, const <a class="el" href="classQDBusConnection.html">QDBusConnection</a> &amp;connection, QObject *parent=0, const char *name=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a proxy for a given peer on a given connection.  <a href="#fac50752f3b0f70d731940257fb60d49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#80f34dfb06dbe62071042fa200e5cedc">~QDBusProxy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys the proxy instance.  <a href="#80f34dfb06dbe62071042fa200e5cedc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#a86593054b60d7e9c908a7aa43c3620f">setConnection</a> (const <a class="el" href="classQDBusConnection.html">QDBusConnection</a> &amp;connection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the DBus connection to work on.  <a href="#a86593054b60d7e9c908a7aa43c3620f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classQDBusConnection.html">QDBusConnection</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#191e6de08ba1226feabcdf43fb0209da">connection</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the currently used DBus connection.  <a href="#191e6de08ba1226feabcdf43fb0209da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#4fba391a291ba48771d6d646d3614417">setService</a> (const QString &amp;service)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the peer's service name.  <a href="#4fba391a291ba48771d6d646d3614417"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">QString&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#9e9029e9b3814eeb90bf010f709fd137">service</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the peer's service name.  <a href="#9e9029e9b3814eeb90bf010f709fd137"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#4d380c57af03ff2d06b16acb081cd388">setPath</a> (const QString &amp;path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the peer's object path.  <a href="#4d380c57af03ff2d06b16acb081cd388"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">QString&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#ebbdad83670c87d109198a94af7cff18">path</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the peer's object path.  <a href="#ebbdad83670c87d109198a94af7cff18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#39ab62a25279c780590eeb55137a407b">setInterface</a> (const QString &amp;interface)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the name of the peer interface.  <a href="#39ab62a25279c780590eeb55137a407b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">QString&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#5fd60383c13572c30f4129ec6350f2bd">interface</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the name of the peer interface.  <a href="#5fd60383c13572c30f4129ec6350f2bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#fe6146cd89bee8e3ff5a91173b0763cd">canSend</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the proxy can be used to send method calls.  <a href="#fe6146cd89bee8e3ff5a91173b0763cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#f49af8199d956a9a7fdaf591f3d46014">send</a> (const QString &amp;method, const QValueList&lt; QVariant &gt; &amp;params) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a method call to the peer object.  <a href="#f49af8199d956a9a7fdaf591f3d46014"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classQDBusMessage.html">QDBusMessage</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#61dc3b418a56affdfd9f586fce315280">sendWithReply</a> (const QString &amp;method, const QValueList&lt; QVariant &gt; &amp;params, <a class="el" href="classQDBusError.html">QDBusError</a> *error=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a method call to the peer object and waits for the reply.  <a href="#61dc3b418a56affdfd9f586fce315280"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#5654ec9c379d7fb5840ba992e472a974">sendWithAsyncReply</a> (const QString &amp;method, const QValueList&lt; QVariant &gt; &amp;params)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a method call to the peer object but does not wait for an answer.  <a href="#5654ec9c379d7fb5840ba992e472a974"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classQDBusError.html">QDBusError</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#81bd2448ee05bdd464394e8907f1c79c">lastError</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the last error seen by the proxy.  <a href="#81bd2448ee05bdd464394e8907f1c79c"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Slots</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#b905df72488825e5022abc74adda23e7">handleDBusSignal</a> (const <a class="el" href="classQDBusMessage.html">QDBusMessage</a> &amp;message)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handles DBus signals received on the proxy's connection.  <a href="#b905df72488825e5022abc74adda23e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#f3588bcca6d2295d72ba979d9bc9cc4f">handleAsyncReply</a> (const <a class="el" href="classQDBusMessage.html">QDBusMessage</a> &amp;message)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handles replies to asynchronous method calls.  <a href="#f3588bcca6d2295d72ba979d9bc9cc4f"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#b9a30a2e2ee01855214737c2e9d9d2d3">QDBusProxy</a> (const <a class="el" href="classQDBusProxy.html">QDBusProxy</a> &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classQDBusProxy.html">QDBusProxy</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#db17e57ee05b57744d61b4f8487467cf">operator=</a> (const <a class="el" href="classQDBusProxy.html">QDBusProxy</a> &amp;)</td></tr>

<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classQDBusProxy_1_1Private.html">Private</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy.html#6ed7aee0ce83bb5589d49c469e66dbfa">d</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQDBusProxy_1_1Private.html">Private</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Client interface to a remote service object. 
<p>
<a class="el" href="classQDBusProxy.html" title="Client interface to a remote service object.">QDBusProxy</a> provides a convenience interface for working with DBus services, or more precisely, interfaces of DBus service objects.<p>
A DBus service object is identified through the name of its host application on the bus and its path (logical location) within the host application. Such a service object can implement any number of interfaces, i.e. groups methods and signals, and can create a <a class="el" href="classQDBusProxy.html" title="Client interface to a remote service object.">QDBusProxy</a> instance for every one your application needs to work with.<p>
See section <a class="el" href="dbusclient.html">Using DBus as a client</a> for documentation on how to use <a class="el" href="classQDBusProxy.html" title="Client interface to a remote service object.">QDBusProxy</a> <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="135144b31c4615667503f75d93347cc0"></a><!-- doxytag: member="QDBusProxy::QDBusProxy" ref="135144b31c4615667503f75d93347cc0" args="(QObject *parent=0, const char *name=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusProxy::QDBusProxy           </td>
          <td>(</td>
          <td class="paramtype">QObject *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a proxy without binding it to a service or connection. 
<p>
This basic constructor allows to create a proxy and specify the peer object and interface later on.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>QObject parent </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>QObject name </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c4d39333bc9908bc196dac8887123b48"></a><!-- doxytag: member="QDBusProxy::QDBusProxy" ref="c4d39333bc9908bc196dac8887123b48" args="(const QDBusConnection &amp;connection, QObject *parent=0, const char *name=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusProxy::QDBusProxy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQDBusConnection.html">QDBusConnection</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a proxy on a given connection without binding it to a service. 
<p>
Similar to the above constructor, it does not yet specify and details about the proxy's peer, but already specifies which connection to work on.<p>
This can be useful to monitor all signal on a connection without filtering for a specific peer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the DBus connection to work on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>QObject parent </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>QObject name </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fac50752f3b0f70d731940257fb60d49"></a><!-- doxytag: member="QDBusProxy::QDBusProxy" ref="fac50752f3b0f70d731940257fb60d49" args="(const QString &amp;service, const QString &amp;path, const QString &amp;interface, const QDBusConnection &amp;connection, QObject *parent=0, const char *name=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusProxy::QDBusProxy           </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQDBusConnection.html">QDBusConnection</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a proxy for a given peer on a given connection. 
<p>
This creates a proxy for a specific peer object-interface combination It is equvalent to creating an "empty" proxy and calling <a class="el" href="classQDBusProxy.html#a86593054b60d7e9c908a7aa43c3620f" title="Sets the DBus connection to work on.">setConnection()</a>, <a class="el" href="classQDBusProxy.html#4fba391a291ba48771d6d646d3614417" title="Sets the peer&#39;s service name.">setService()</a>, <a class="el" href="classQDBusProxy.html#4d380c57af03ff2d06b16acb081cd388" title="Sets the peer&#39;s object path.">setPath()</a> and <a class="el" href="classQDBusProxy.html#39ab62a25279c780590eeb55137a407b" title="Sets the name of the peer interface.">setInterface()</a> manually.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>service</em>&nbsp;</td><td>the name the peer's host application uses on the bus </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>the peer object's path within its host application </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interface</em>&nbsp;</td><td>the interface to work with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the DBus connection to work on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>QObject parent </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>QObject name </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="80f34dfb06dbe62071042fa200e5cedc"></a><!-- doxytag: member="QDBusProxy::~QDBusProxy" ref="80f34dfb06dbe62071042fa200e5cedc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusProxy::~QDBusProxy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys the proxy instance. 
<p>

</div>
</div><p>
<a class="anchor" name="b9a30a2e2ee01855214737c2e9d9d2d3"></a><!-- doxytag: member="QDBusProxy::QDBusProxy" ref="b9a30a2e2ee01855214737c2e9d9d2d3" args="(const QDBusProxy &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusProxy::QDBusProxy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQDBusProxy.html">QDBusProxy</a> &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a86593054b60d7e9c908a7aa43c3620f"></a><!-- doxytag: member="QDBusProxy::setConnection" ref="a86593054b60d7e9c908a7aa43c3620f" args="(const QDBusConnection &amp;connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool QDBusProxy::setConnection           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQDBusConnection.html">QDBusConnection</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the DBus connection to work on. 
<p>
Disconnects from any previously used connection and connects to the new connection's signal distribution. If no peer information has been provided at creation time or through the other set methods, the instance's signal <a class="el" href="classQDBusProxy.html#6da8694c00848352284f08d0a6f232a9" title="Signal emitted for DBus signals from the peer.">dbusSignal()</a> will emit all signals received on the given connection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>the DBus connection to work on</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if connecting to the new connection's signal succeeded, <code>false</code> if it failed, e.g. if the connection is a "null" connection</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classQDBusProxy.html#191e6de08ba1226feabcdf43fb0209da" title="Returns the currently used DBus connection.">connection()</a> <p>
<a class="el" href="classQDBusProxy.html#4fba391a291ba48771d6d646d3614417" title="Sets the peer&#39;s service name.">setService()</a> <p>
<a class="el" href="classQDBusProxy.html#4d380c57af03ff2d06b16acb081cd388" title="Sets the peer&#39;s object path.">setPath()</a> <p>
<a class="el" href="classQDBusProxy.html#39ab62a25279c780590eeb55137a407b" title="Sets the name of the peer interface.">setInterface()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="191e6de08ba1226feabcdf43fb0209da"></a><!-- doxytag: member="QDBusProxy::connection" ref="191e6de08ba1226feabcdf43fb0209da" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classQDBusConnection.html">QDBusConnection</a> &amp; QDBusProxy::connection           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the currently used DBus connection. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classQDBusProxy.html#a86593054b60d7e9c908a7aa43c3620f" title="Sets the DBus connection to work on.">setConnection()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4fba391a291ba48771d6d646d3614417"></a><!-- doxytag: member="QDBusProxy::setService" ref="4fba391a291ba48771d6d646d3614417" args="(const QString &amp;service)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QDBusProxy::setService           </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>service</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the peer's service name. 
<p>
A non-empty service name is required if the proxy is to be used for method calls. See section <a class="el" href="dbusconventions.html#dbusconventions-servicename">Service names</a> for details.<p>
If a string other than <code>QString::null</code> is set, it will be used to filter signals, i.e. a signal received by the proxy will only be emitted if the service name matches.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>service</em>&nbsp;</td><td>the peer's name on the bus</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classQDBusProxy.html#9e9029e9b3814eeb90bf010f709fd137" title="Returns the peer&#39;s service name.">service()</a> <p>
<a class="el" href="classQDBusProxy.html#4d380c57af03ff2d06b16acb081cd388" title="Sets the peer&#39;s object path.">setPath()</a> <p>
<a class="el" href="classQDBusProxy.html#39ab62a25279c780590eeb55137a407b" title="Sets the name of the peer interface.">setInterface()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9e9029e9b3814eeb90bf010f709fd137"></a><!-- doxytag: member="QDBusProxy::service" ref="9e9029e9b3814eeb90bf010f709fd137" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString QDBusProxy::service           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the peer's service name. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the peer object's service name</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classQDBusProxy.html#4fba391a291ba48771d6d646d3614417" title="Sets the peer&#39;s service name.">setService()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4d380c57af03ff2d06b16acb081cd388"></a><!-- doxytag: member="QDBusProxy::setPath" ref="4d380c57af03ff2d06b16acb081cd388" args="(const QString &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QDBusProxy::setPath           </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the peer's object path. 
<p>
A non-empty object path is required if the proxy is to be used for method calls. See section <a class="el" href="dbusconventions.html#dbusconventions-objectpath">Object paths</a> for details.<p>
If a string other than <code>QString::null</code> is set, it will be used to filter signals, i.e. a signal received by the proxy will only be emitted if the object path matches.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>the peer's object path inside its host application (logical address)</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classQDBusProxy.html#ebbdad83670c87d109198a94af7cff18" title="Returns the peer&#39;s object path.">path()</a> <p>
<a class="el" href="classQDBusProxy.html#4fba391a291ba48771d6d646d3614417" title="Sets the peer&#39;s service name.">setService()</a> <p>
<a class="el" href="classQDBusProxy.html#39ab62a25279c780590eeb55137a407b" title="Sets the name of the peer interface.">setInterface()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ebbdad83670c87d109198a94af7cff18"></a><!-- doxytag: member="QDBusProxy::path" ref="ebbdad83670c87d109198a94af7cff18" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString QDBusProxy::path           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the peer's object path. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the peer object's path</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classQDBusProxy.html#4d380c57af03ff2d06b16acb081cd388" title="Sets the peer&#39;s object path.">setPath()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="39ab62a25279c780590eeb55137a407b"></a><!-- doxytag: member="QDBusProxy::setInterface" ref="39ab62a25279c780590eeb55137a407b" args="(const QString &amp;interface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QDBusProxy::setInterface           </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>interface</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the name of the peer interface. 
<p>
A non-empty interface name is required if the proxy is to be used for method calls. See section <a class="el" href="dbusconventions.html#dbusconventions-interfacename">Interface names</a> for details.<p>
If a string other than <code>QString::null</code> is set, it will be used to filter signals, i.e. a signal received by the proxy will only be emitted if the interface name matches.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>interface</em>&nbsp;</td><td>the peer's interface to work with</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classQDBusProxy.html#5fd60383c13572c30f4129ec6350f2bd" title="Returns the name of the peer interface.">interface()</a> <p>
<a class="el" href="classQDBusProxy.html#4fba391a291ba48771d6d646d3614417" title="Sets the peer&#39;s service name.">setService()</a> <p>
<a class="el" href="classQDBusProxy.html#4d380c57af03ff2d06b16acb081cd388" title="Sets the peer&#39;s object path.">setPath()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5fd60383c13572c30f4129ec6350f2bd"></a><!-- doxytag: member="QDBusProxy::interface" ref="5fd60383c13572c30f4129ec6350f2bd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString QDBusProxy::interface           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of the peer interface. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the peer object's interface</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classQDBusProxy.html#39ab62a25279c780590eeb55137a407b" title="Sets the name of the peer interface.">setInterface()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="fe6146cd89bee8e3ff5a91173b0763cd"></a><!-- doxytag: member="QDBusProxy::canSend" ref="fe6146cd89bee8e3ff5a91173b0763cd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool QDBusProxy::canSend           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether the proxy can be used to send method calls. 
<p>
The capabilitly to send method calls depends on having all necessary base information:<ul>
<li>Service name, see <a class="el" href="classQDBusProxy.html#4fba391a291ba48771d6d646d3614417" title="Sets the peer&#39;s service name.">setService()</a></li><li>Object path, see <a class="el" href="classQDBusProxy.html#4d380c57af03ff2d06b16acb081cd388" title="Sets the peer&#39;s object path.">setPath()</a></li><li>Interface, see <a class="el" href="classQDBusProxy.html#39ab62a25279c780590eeb55137a407b" title="Sets the name of the peer interface.">setInterface()</a></li></ul>
<p>
and a working connection, see <a class="el" href="classQDBusProxy.html#a86593054b60d7e9c908a7aa43c3620f" title="Sets the DBus connection to work on.">setConnection()</a><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if method calls can be sent, <code>false</code> if any of the three base information is missing or if the connection is not connected</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classQDBusProxy.html#f49af8199d956a9a7fdaf591f3d46014" title="Sends a method call to the peer object.">send()</a> <p>
<a class="el" href="classQDBusProxy.html#61dc3b418a56affdfd9f586fce315280" title="Sends a method call to the peer object and waits for the reply.">sendWithReply()</a> <p>
<a class="el" href="classQDBusProxy.html#5654ec9c379d7fb5840ba992e472a974" title="Sends a method call to the peer object but does not wait for an answer.">sendWithAsyncReply()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f49af8199d956a9a7fdaf591f3d46014"></a><!-- doxytag: member="QDBusProxy::send" ref="f49af8199d956a9a7fdaf591f3d46014" args="(const QString &amp;method, const QValueList&lt; QVariant &gt; &amp;params) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool QDBusProxy::send           </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QValueList&lt; QVariant &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>params</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends a method call to the peer object. 
<p>
This is roughly equivalent to calling a C++ method with no return value or like ignoring the it.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>the name of the method to invoke </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>the method parameters. Use an empty list if the method does not require parameters</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if sending succeeded, <code>false</code> if sending failed, the method name was empty or any of the conditions for successfull sending as described for <a class="el" href="classQDBusProxy.html#fe6146cd89bee8e3ff5a91173b0763cd" title="Returns whether the proxy can be used to send method calls.">canSend()</a> are not met</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classQDBusProxy.html#81bd2448ee05bdd464394e8907f1c79c" title="Returns the last error seen by the proxy.">lastError()</a> <p>
<a class="el" href="classQDBusProxy.html#61dc3b418a56affdfd9f586fce315280" title="Sends a method call to the peer object and waits for the reply.">sendWithReply()</a> <p>
<a class="el" href="classQDBusProxy.html#5654ec9c379d7fb5840ba992e472a974" title="Sends a method call to the peer object but does not wait for an answer.">sendWithAsyncReply()</a> <p>
<a class="el" href="dbusconventions.html#dbusconventions-membername">Method and signal names</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="61dc3b418a56affdfd9f586fce315280"></a><!-- doxytag: member="QDBusProxy::sendWithReply" ref="61dc3b418a56affdfd9f586fce315280" args="(const QString &amp;method, const QValueList&lt; QVariant &gt; &amp;params, QDBusError *error=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQDBusMessage.html">QDBusMessage</a> QDBusProxy::sendWithReply           </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QValueList&lt; QVariant &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQDBusError.html">QDBusError</a> *&nbsp;</td>
          <td class="paramname"> <em>error</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends a method call to the peer object and waits for the reply. 
<p>
This is roughly equivalent to calling a C++ method on a local object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>the name of the method to invoke </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>the method parameters. Use an empty list if the method does not require parameters </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>optional parameter to get any error directly</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="classQDBusMessage.html" title="A message converts and transports data over DBus.">QDBusMessage</a> containing any return values of the invoked method. Will be an invalid message if an error occurs. The error can be accessed through the optional paramater <code>error</code> or through <a class="el" href="classQDBusProxy.html#81bd2448ee05bdd464394e8907f1c79c" title="Returns the last error seen by the proxy.">lastError()</a></dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classQDBusProxy.html#fe6146cd89bee8e3ff5a91173b0763cd" title="Returns whether the proxy can be used to send method calls.">canSend()</a> <p>
<a class="el" href="classQDBusProxy.html#f49af8199d956a9a7fdaf591f3d46014" title="Sends a method call to the peer object.">send()</a> <p>
<a class="el" href="classQDBusProxy.html#5654ec9c379d7fb5840ba992e472a974" title="Sends a method call to the peer object but does not wait for an answer.">sendWithAsyncReply()</a> <p>
<a class="el" href="dbusconventions.html#dbusconventions-membername">Method and signal names</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5654ec9c379d7fb5840ba992e472a974"></a><!-- doxytag: member="QDBusProxy::sendWithAsyncReply" ref="5654ec9c379d7fb5840ba992e472a974" args="(const QString &amp;method, const QValueList&lt; QVariant &gt; &amp;params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int QDBusProxy::sendWithAsyncReply           </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QValueList&lt; QVariant &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>params</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends a method call to the peer object but does not wait for an answer. 
<p>
This is roughly equivalent to calling a C++ method on a local Qt event loop driven object, where the result of the method call is delivered later through a signal.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>as with Qt's asychronous classes this needs a running event loop</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>the name of the method to invoke </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>the method parameters. Use an empty list if the method does not require parameters</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a serial number to easily identify the reply once it is received or 0 if the call is not possible, i.e. the method name is empty or any of the conditions for <a class="el" href="classQDBusProxy.html#fe6146cd89bee8e3ff5a91173b0763cd" title="Returns whether the proxy can be used to send method calls.">canSend()</a> are not met</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>if a asynchronous call is followed by a synchronous call, e.g. using <a class="el" href="classQDBusProxy.html#61dc3b418a56affdfd9f586fce315280" title="Sends a method call to the peer object and waits for the reply.">sendWithReply()</a>, without returning to the event loop, is recommended to call <a class="el" href="classQDBusConnection.html#2b05e9b7b118b528baddf0c957a9570b" title="Request a delayed check for inbound buffer processing.">QDBusConnection::scheduleDispatch()</a> after the synchronous call to make sure any reply received during the blocking call is delivered</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classQDBusProxy.html#884668d72219475bf0378e7e73c74c40" title="Signal emitted for received replies to asynchronous method calls.">asyncReply()</a> <p>
<a class="el" href="classQDBusProxy.html#f49af8199d956a9a7fdaf591f3d46014" title="Sends a method call to the peer object.">send()</a> <p>
<a class="el" href="classQDBusProxy.html#61dc3b418a56affdfd9f586fce315280" title="Sends a method call to the peer object and waits for the reply.">sendWithReply()</a> <p>
<a class="el" href="dbusconventions.html#dbusconventions-membername">Method and signal names</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="81bd2448ee05bdd464394e8907f1c79c"></a><!-- doxytag: member="QDBusProxy::lastError" ref="81bd2448ee05bdd464394e8907f1c79c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQDBusError.html">QDBusError</a> QDBusProxy::lastError           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the last error seen by the proxy. 
<p>
The last error can a connection error, e.g. sending a message failed due connection being lost, or the error of the last call to sendWithReply or the error of the last received <a class="el" href="classQDBusProxy.html#884668d72219475bf0378e7e73c74c40" title="Signal emitted for received replies to asynchronous method calls.">asyncReply()</a><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the last dbus error seen by this proxy </dd></dl>

</div>
</div><p>
<a class="anchor" name="6da8694c00848352284f08d0a6f232a9"></a><!-- doxytag: member="QDBusProxy::dbusSignal" ref="6da8694c00848352284f08d0a6f232a9" args="(const QDBusMessage &amp;message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QDBusProxy::dbusSignal           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQDBusMessage.html">QDBusMessage</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>message</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signal emitted for DBus signals from the peer. 
<p>
Signals received on the proxy's connection are filtered by <a class="el" href="classQDBusProxy.html#b905df72488825e5022abc74adda23e7" title="Handles DBus signals received on the proxy&#39;s connection.">handleDBusSignal()</a> for all proxy properties that are not empty.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>message</em>&nbsp;</td><td>the signal's content</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classQDBusMessage.html#99ffac3ccf917a669ad01a63336d717be8590a089ef5b84aa40dbe46e1b93807">QDBusMessage::SignalMessage</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="884668d72219475bf0378e7e73c74c40"></a><!-- doxytag: member="QDBusProxy::asyncReply" ref="884668d72219475bf0378e7e73c74c40" args="(int callID, const QDBusMessage &amp;message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QDBusProxy::asyncReply           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>callID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQDBusMessage.html">QDBusMessage</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>message</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signal emitted for received replies to asynchronous method calls. 
<p>
If a method invoked by using <a class="el" href="classQDBusProxy.html#5654ec9c379d7fb5840ba992e472a974" title="Sends a method call to the peer object but does not wait for an answer.">sendWithAsyncReply()</a> send a response, e.g. method return value or errors, this signal is emitted to notify the proxy's user.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>callID</em>&nbsp;</td><td>the method call's serial number as returned by <a class="el" href="classQDBusProxy.html#5654ec9c379d7fb5840ba992e472a974" title="Sends a method call to the peer object but does not wait for an answer.">sendWithAsyncReply()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>message</em>&nbsp;</td><td>the reply's content</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classQDBusProxy.html#f3588bcca6d2295d72ba979d9bc9cc4f" title="Handles replies to asynchronous method calls.">handleAsyncReply()</a> <p>
<a class="el" href="classQDBusMessage.html#f8a51f73dc5d59d8ef6f9c357533317e" title="Returns the message&#39;s reply serial number.">QDBusMessage::replySerialNumber()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b905df72488825e5022abc74adda23e7"></a><!-- doxytag: member="QDBusProxy::handleDBusSignal" ref="b905df72488825e5022abc74adda23e7" args="(const QDBusMessage &amp;message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QDBusProxy::handleDBusSignal           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQDBusMessage.html">QDBusMessage</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>message</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Handles DBus signals received on the proxy's connection. 
<p>
The base implementation checks each non-empty property, i.e. service name, object path and interface, with the respective field of the signal's DBus message.<p>
If all available matches succeed, the message is emitted by <a class="el" href="classQDBusProxy.html#6da8694c00848352284f08d0a6f232a9" title="Signal emitted for DBus signals from the peer.">dbusSignal()</a>, otherwise it is discarded.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>message</em>&nbsp;</td><td>the DBus signal message as received</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classQDBusMessage.html#99ffac3ccf917a669ad01a63336d717be8590a089ef5b84aa40dbe46e1b93807">QDBusMessage::SignalMessage</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f3588bcca6d2295d72ba979d9bc9cc4f"></a><!-- doxytag: member="QDBusProxy::handleAsyncReply" ref="f3588bcca6d2295d72ba979d9bc9cc4f" args="(const QDBusMessage &amp;message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QDBusProxy::handleAsyncReply           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQDBusMessage.html">QDBusMessage</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>message</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Handles replies to asynchronous method calls. 
<p>
The base implementation simply extracts the reply's error and makes it available for <a class="el" href="classQDBusProxy.html#81bd2448ee05bdd464394e8907f1c79c" title="Returns the last error seen by the proxy.">lastError()</a>. It then emits <a class="el" href="classQDBusProxy.html#884668d72219475bf0378e7e73c74c40" title="Signal emitted for received replies to asynchronous method calls.">asyncReply()</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>message</em>&nbsp;</td><td>the DBus reply message as received</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classQDBusMessage.html#f8a51f73dc5d59d8ef6f9c357533317e" title="Returns the message&#39;s reply serial number.">QDBusMessage::replySerialNumber()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="db17e57ee05b57744d61b4f8487467cf"></a><!-- doxytag: member="QDBusProxy::operator=" ref="db17e57ee05b57744d61b4f8487467cf" args="(const QDBusProxy &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQDBusProxy.html">QDBusProxy</a>&amp; QDBusProxy::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQDBusProxy.html">QDBusProxy</a> &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="6ed7aee0ce83bb5589d49c469e66dbfa"></a><!-- doxytag: member="QDBusProxy::d" ref="6ed7aee0ce83bb5589d49c469e66dbfa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQDBusProxy_1_1Private.html">Private</a>* <a class="el" href="classQDBusProxy.html#6ed7aee0ce83bb5589d49c469e66dbfa">QDBusProxy::d</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="qdbusproxy_8h-source.html">qdbusproxy.h</a><li><a class="el" href="qdbusproxy_8cpp.html">qdbusproxy.cpp</a></ul>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Jan 12 13:15:01 2008 for dbus-qt3-backport by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.4 </small></address>
</body>
</html>

#!/usr/bin/python
# -*- coding: utf-8 -*-

import sys
from optparse import OptionParser

import pisi
from pisi.cli import buildhelper, installhelper, indexhelper

usage = """%prog <command> [options] [arguments]

where <command> is one of:

help
build
install
index
updatedb

Use \"%prog help <command>\" for help on a specific subcommand.

PISI Package Manager
"""

# def commonopts(parser):
#     parser.add_option("-D", "--destdir", action="store")
#     parser.add_option("-u", "--username", action="store")
#     parser.add_option("-p", "--password", action="store")
#     parser.add_option("-P", action="store_true", dest="getpass", default=False,
#                       help="Get password from the command line")
#     parser.add_option("-v", "--verbose", action="store_true",
#                       dest="verbose", default=False,
#                       help="detailed output")
#     parser.add_option("-d", "--debug", action="store_true",
#                       default=True, help="show debugging information")
#     parser.add_option("-n", "--dry-run", action="store_true", default=False,
#                       help = "do not perform any action, just show what\
#                       would be done")
#     return parser


class ParserError:
    def __init__(self, msg):
        self.msg = msg

class Parser(OptionParser):

    def __init__(self, usage, version):
        OptionParser.__init__(self, usage=usage, version=version)

    def error(self, msg):
        raise ParserError(msg)

class PisiCLI(object):

    commands = ["help", "build", "install", "index", "updatedb"]
    
    def __init__(self):

        # first construct a parser for common options
        # this is really dummy
        parser = Parser(usage=usage, version="%prog " + pisi.__version__)
#        parser.allow_interspersed_args = False
#        parser = commonopts(parser)
        parser.add_option("-D", "--destdir", action="store")
        parser.add_option("-u", "--username", action="store")
        parser.add_option("-p", "--password", action="store")
        parser.add_option("-P", action="store_true", dest="getpass", default=False,
                          help="Get password from the command line")
        parser.add_option("-v", "--verbose", action="store_true",
                          dest="verbose", default=False,
                          help="detailed output")
        parser.add_option("-d", "--debug", action="store_true",
                          default=True, help="show debugging information")
        parser.add_option("-n", "--dry-run", action="store_true", default=False,
                          help = "do not perform any action, just show what\
                          would be done")

        self.command = ""
        try:
            (options, args) = parser.parse_args()
#            if len(parser.rargs)==0:
#                self.die()
            self.command = args[0]
        except ParserError:
            # fully expected :) let's see if we got an argument
            if len(parser.rargs)==0:
                self.die()
            #print 'rargs', parser.rargs, 'vals', parser.values
            self.command = parser.rargs[0]

#         # now for the real parser
#         parser = OptionParser(usage=usage, version="%prog " + pisi.__version__)
#         parser.allow_interspersed_args = False
#         self.parser = commonopts(parser)    
#         self.add_subcommand_opts()
#         (self.options, args) = self.parser.parse_args()
        self.args = args[1:]
        self.options = options

        self.authInfo = None
        self.checkAuthInfo()

    def die(self):
        print usage
        sys.exit(1)

    def add_subcommand_opts(self):
        if self.command in self.commands:
            f = self.__getattribute__(self.command + '_opts')
            f()
        else:
            print 'Unrecognized command:', self.command
            self.die()

    def runCommand(self):
        if self.command in self.commands:
            f = self.__getattribute__(self.command)
            f()
        else:
            print 'Unrecognized command:', self.command
            self.die()

    def checkAuthInfo(self):
        username = self.options.username
        password = self.options.password
        if not username and not password:
            return # No authentication
        elif username and password:
            self.authInfo = (username, password)
            return

        # TODO: yapılandırma dosyasını da kontrol et. Belki orada
        # tanımlanmıştır?


        if username and self.options.getpass:
            from getpass import getpass
            password = getpass("Password: ")
            self.authInfo = (username, password)
        return
            

    # FIX: her komut için ayrı help
    def help_opts(self):
        pass

    def help(self, command=""):
        if not self.args:
            print usage
            return

        self.parser.print_help()

    def index_opts(self):
        pass

    def index(self):
        if not self.args:
            self.help("index")

        if len(self.args)==1:
            indexhelper.index(self.args[0])
        elif len(self.args)==0:
            indexhelper.index()
        else:
            print 'Indexing only a single directory supported'
            self.die()

    def install_opts(self):
        self.parser.add_option("", "--test", action="store_true",
                               default=True, help="xxxx")

    def install(self):
        if not self.args:
            self.help("install")
        for arg in self.args:
            installhelper.install(arg)

    def build_opts(self):
        pass

    def build(self):
        if not self.args:
            self.help("build")

        for arg in self.args:
            buildhelper.build(arg, self.authInfo)

    def updatedb_opts(self):
        pass

    def updatedb(self):
        """Update the repos db with the given index file (pisi-index.xml)"""
        if len(self.args) != 1:
            self.help("updatedb")

        indexfile = self.args[0]
        indexhelper.updatedb(indexfile)

if __name__ == "__main__":
    cli = PisiCLI()
    cli.runCommand()

Like every serious project, there are guidelines.
Oooooo. "Coding Standards".

Guidelines
----------

1. When using dirnames, don't expect the dir to end
   with a trailing slash, and please use the dirnames
   in pisiconfig
2. Python indentation is usually 4 chars.
3. Follow python philosophy of 'batteries included'
4. Don't make the code have runtime dependencies on
   a particular distribution (as much as possible)
5. Don't assume narrow use cases.
6. If you are changing something, check if that change
   breaks anything and fix breakage. For instance a
   name. Running the tests is not always enough!
7. We all know, you're using LISP but didn't want to tell 
   us. Don't scare, as a success story and for your encouregment
   there are tens of people on somewhere with LISP releated jobs.
8. If you are studying Data structures and Algorithms, and if
   your first assignment is implementing a basic stack for 
   presedence, don't implement it. Just show your teacher the
   syntax of LISP, tell him how beatifull it is, and show how can 
   otistic person can count lots of paranthesis with "one second" look,
   probably you'll get A+.
9. If you are interesting with "Playstation 2 Linux Games Programming" 
   or "How to extend C programs with Guile", please don't.

Unit testing
------------

Unit tests are located in unittests directory. Running the tests is
trivial. But you must synchronize your code and data with the test
code, which can be a tedious work if you lose discipline.

Sample data files are located in the same directory with test modules.

For running the entire test suite, use the following command:

$ ./tests/run.py

The following command will run tests in specfiletests and archivetests
in unittests dir:

$ ./tests/run.py specfile archive

Do not depend on the output of unittests. Instead of producing an
output message/data in your tests, check the data internally. By
definition, unittest should just report succeeding and failing cases.

If you didn't, take a look at the links below for having an idea of
unit testing.
http://www.extremeprogramming.org/rules/unittests.html
http://www.extremeprogramming.org/rules/unittests2.html


Misc. Suggestions
-----------------

1. Demeter's Law

In OO programming, try to invoke Demeter's law.
One of the "rules" there is not directly accessing any
objects that are further than, 2/3 refs, away. So the
following code is OK.
   destroy_system(a.system().name())
but the following isn't as robust
   destroy_system(object_store.root().a.system.name())
As you can tell, this introduces too many implementation
dependencies. The rule of thumb is that, in these cases
this statement must have been elsewhere.... It may be a
good idea to not count the object scope in this case,
so in Python self.a means only one level of reference,
not two.

One quibble with this: it may be preferable not to insist
on this where it would be inefficient. So if everything
is neatly packed into one object contained in another
object, why replicate everything in the upper level? If
the semantics prevents dependency changes, then chains
of 3 or even 4 could be acceptable.

OTOH, in Python and C++, it's not always good to implement 
accessor/modifier pairs for every property of an object.
It would be much simpler if you are not doing any special
processing on the property (e.g. if what the type system
does is sufficient).

The main rule of thumb in Demeter's Law is avoiding
putting more than, say, 10 methods in a class. That works
really well in practice, forcing refactoring every now
and then.

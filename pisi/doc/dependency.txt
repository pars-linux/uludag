Dependency Resolution in PISI

Eray Ozkural



1. Introduction

Dependency resolution in package management systems have a
significance in that they are the key to providing system stability
and internet upgrades. The scale of package databases requires the
dependency resolution mechanism to be efficient and correct,
motivating a closer look at the theory.


2. Review

Dependency resolution has been taken in the most general setting as
the famous SAT problem of propositional logic. If we consider a system
D of dependency statements D_i, each statement can be taken as a 
proposition in propositional logic which states, for
instance:

D_i:   if package a is installed or package b is installed, then package i
is installable.
...

The system is thus understood as the conjunction of such facts, giving
us a logical programming system for determining installation conditions.

Note that for simplicity we do not consider the nuances in upgrade and
remove operations at the moment.

However, using a SAT solver for this operation may be shooting a fly
with a bazooka. We observe that only certain forms of propositions
will be necessary for a dependency system. Furthermore, as we shall
see further constraints and optimizations may be required of the
system that are not modelled well with SAT problem.


3. Package operation planning

The dependency resolution problem may be viewed as a simple forward
chaining problem, where we would like to begin from an initial state
S_0 and by following allowable system transitions t_i: S -> S, 
arrive at a desired system state S_f.

A system state S_i is defined as the set of installed packages on the
system together with their versions, i.e. S_i = { (x,v) : x is
installed, v=version(x)}. An atomic system transition t_i chains one
system state into another, making one ACID change on the system. The
usual atomic transitions are the single package install, remove and
upgrade operations found in low-level package management code.

A package operation plan is thus naturally conceived of as a sequence
of atomic system transitions. Given an initial state and a final
state, the job of the package operation planner is to determine
whether there is a plan, and if so find the "best" one.

Where there are no versions involved (e.g. upgrade/downgrade), we will
replace the pair (x,v) with x.

3.1 System consistency

It is worth mentioning here the concept of system consistency. As in a
database transaction, it is not acceptable that the system violates an
invariant afterwards. In the context of PISI, system consistency is
composed of two conditions for the current set of installed packages.
  1. All package dependencies are satisfied (we may call this a closed system)
  2. No package conflicts are present.

Therefore, by atomic transition we also mean one that does not corrupt
system consistency. The system is thus never in an inconsistent state.


3.2 Solving the simplest case with topological sorting

We will now concentrate on a simple form of the problem which can
be solved with topological sorting. This form is not concerned with
versions. From initial set of packages S_0, we would like to
install in addition a new set A of packages obtaining S_f = S_0 \cup A.

The only relations considered are of the form: a Depends on b, or more
shortly aDb.

The graph of all such simple dependency relations is a directed graph
(digraph) G. For each dependency relation aDB, there is an edge a ->
b in G. Accessing graph G usually requires a database operation and
is therefore expensive.

We now consider the digraph G_A of the minimal set of simple
dependency relations which contains all information required to
construct a plan to install packages A. G_A is a vertex induced graph
such that the fringe of $A$, e.g. vertices with out-degree $0$ are
already installed. Vertices of G_A are taken from S_f. First, let us
explain the labelling scheme. Already installed vertices are labelled
with 'i'. Packages to be added are labelled with 'a', and packages to
be installed due to dependencies are labelled with 'd'. We
construct the graph as follows

  G_A <- isolated vertex set A labelled with 'a'
  repeat
    done <- true
    for each u in V_A with out-degree 0
      for v in adj(u) in G
        if v is not in V_A
           done <- false
           if v is installed
              label v with 'i'
           else
              label v with 'd'
           add (u,v) to G_A
  until done

By this iterative expansion, we do a minimum number of database
accesses to G and construct a dependency graph in memory. If the
G_A's fringe has vertices with non 'i'-labels, then A cannot be
installed. Otherwise, we find a topological sort L of G_A, and in
the reverse order, install packages for vertices labelled with
'a' or 'd'.

4. Complex cases

4.1 A complex upgrade

plan: upgrade (a,1) to (a,2)

rules:
  (a,1) depends on (b,1), (c,1)
  (a,1) conflicts with (d,1)
  (a,2) depends on (c,3), (d,2)
  (a,2) conflicts with (b,1)

initial state:
  (a,1), (b,1), (c,1) installed 

plan:
  remove (b,1)
  upgrade (c,1) -> (c,3)
  install (d,2)
  upgrade (a,1) -> (a,2)

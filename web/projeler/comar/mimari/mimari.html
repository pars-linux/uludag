<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	<title>:: Pardus :: tübitak-uekae ::</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<link href="../../../style.css" rel="stylesheet" type="text/css">
	<link rel="shortcut icon" type="image/x-icon" href="../../../images/favicon.ico">
</head>

<body>
    <div id="container">
    <div id="head_grey">
        <div id="blue2"></div>
    </div>
    <div id="navi">
        <a href="../../../index.html">Ana Sayfa</a>
      | <a href="../../../hakkimizda.html">Hakkımızda</a>
      | <a href="../../../projeler/index.html">Projeler</a>
      | <a href="../../../belgeler/index.html">Belgeler</a>
      | <a href="../../../urunler/index.html">Ürünler</a>
      | <a href="../../../iletisim.html">İletişim</a>
      | <a href="../../../basin/index.html">Basında Pardus</a>
      | <a href="../../../eng/index.html">English</a>
    </div>
    <div id="page">
    <br />
        <div id="fullpage">
<!-- SAYFA İÇERİK BAŞI -->
<div class="belge">


<H1 ALIGN=center>ÇOMAR Mimari Belgesi</H1>

<H3 ALIGN=center>Gürer Özen (gurer @ uludag.org.tr)</H3>
<!--TOC section İçindekiler-->

<H2>İçindekiler</H2><!--SEC END -->

<UL><LI>
<A HREF="#htoc1">1&nbsp;&nbsp;Giriş</A>
<LI><A HREF="#htoc2">2&nbsp;&nbsp;Sorun</A>
<UL><LI>
<A HREF="#htoc3">2.1&nbsp;&nbsp;Belgeler</A>
<LI><A HREF="#htoc4">2.2&nbsp;&nbsp;Diğer Linux Dağıtımları</A>
<LI><A HREF="#htoc5">2.3&nbsp;&nbsp;Diğer İşletim Sistemleri</A>
<LI><A HREF="#htoc6">2.4&nbsp;&nbsp;Özel Yönetim Uygulamaları</A>
</UL>
<LI><A HREF="#htoc7">3&nbsp;&nbsp;Gerekler</A>
<UL><LI>
<A HREF="#htoc8">3.1&nbsp;&nbsp;Kullanıcı Gerekleri</A>
<LI><A HREF="#htoc9">3.2&nbsp;&nbsp;Geliştirici Gerekleri</A>
</UL>
<LI><A HREF="#htoc10">4&nbsp;&nbsp;ÇOMAR</A>
<UL><LI>
<A HREF="#htoc11">4.1&nbsp;&nbsp;Sistem Modeli</A>
<LI><A HREF="#htoc12">4.2&nbsp;&nbsp;Aracı Programcıklar (CSL)</A>
<LI><A HREF="#htoc13">4.3&nbsp;&nbsp;Yapılandırma Yöneticisi</A>
<LI><A HREF="#htoc14">4.4&nbsp;&nbsp;Kullanıcı Arayüzleri</A>
</UL>
<LI><A HREF="#htoc15">5&nbsp;&nbsp;Sıkça Sorulanlar</A>
<UL><LI>
<A HREF="#htoc16">5.1&nbsp;&nbsp;ÇOMAR'ın açılımı nedir?</A>
<LI><A HREF="#htoc17">5.2&nbsp;&nbsp;ÇOMAR bana ne fayda sağlayacak?</A>
<LI><A HREF="#htoc18">5.3&nbsp;&nbsp;ÇOMAR desteklemeyen uygulamaları kullanabilecek miyim?</A>
<LI><A HREF="#htoc19">5.4&nbsp;&nbsp;Bir uygulamaya ÇOMAR desteği vermek zor mu?</A>
<LI><A HREF="#htoc20">5.5&nbsp;&nbsp;CSL yeni bir dil mi?</A>
<LI><A HREF="#htoc21">5.6&nbsp;&nbsp;ÇOMAR ile PİSİ arasında nasıl bir ilişki var?</A>
<LI><A HREF="#htoc22">5.7&nbsp;&nbsp;ÇOMAR'ı devreden çıkartırsam ne olur?</A>
<LI><A HREF="#htoc23">5.8&nbsp;&nbsp;ÇOMAR'ın kconfig, gconf, elektra gibi sistemlerden farkı ne?</A>
<LI><A HREF="#htoc24">5.9&nbsp;&nbsp;Neden başkaları böyle bir çözüm getirmedi?</A>
</UL>
<LI><A HREF="#htoc25">6&nbsp;&nbsp;Emeği Geçenler</A>
</UL>

<!--TOC section Giriş-->

<H2><A NAME="htoc1">1</A>&nbsp;&nbsp;Giriş</H2><!--SEC END -->

Bu belge, Ulusal Dağıtım'ın yapılandırma yönetim sistemi olan ÇOMAR'ın,
ne amaçla geliştirildiğini, hangi sorunlara çözüm getirdiğini, yapısını
ve bileşenlerini anlatır. Hedef kitlesi, ÇOMAR'ı yakından tanımak
isteyen kullanıcılar ve sistem yöneticileridir. Bilişim okuryazarı
seviyesine göre yazılmış olmakla birlikte, bazı tartışmaları takip
edebilmek için, bir işletim sisteminin bileşenleri, ve uygulamaların
nasıl ayarlandığı gibi sistem yönetimi konularında bilgi sahibi olmak
gerekebilir.<BR>
<BR>
<!--TOC section Sorun-->

<H2><A NAME="htoc2">2</A>&nbsp;&nbsp;Sorun</H2><!--SEC END -->

Çeşitli uygulamalar bir sistem içinde bir araya getirildiklerinde,
birbirleriyle uyumlu çalışabilmeleri için ayarlanmaları gerekmektedir.
Kurulan bir uygulamanın masaüstü menüsüne eklenmesi, açabildiği dosya
tiplerini sisteme bildirmesi, yeni kurulan bir spam (istenmeyen eposta)
filtreleyicinin mevcut eposta sunucusuna bağlanması gibi çok sayıda
entegrasyon işlemi bulunmaktadır. Kullanıcı, bu ayarları yapabilmek
için, kendi yapmak istediği işin dışındaki teknik konularda bilgi
kazanmak zorunda kalmakta ve zaman kaybetmektedir.<BR>
<BR>
<!--TOC subsection Belgeler-->

<H3><A NAME="htoc3">2.1</A>&nbsp;&nbsp;Belgeler</H3><!--SEC END -->

Özgür yazılım camiası, bu işleri kolaylaştırmak için ``nasıl''
(ing. howto) belgeleri adıyla çeşitli belgeler hazırlamıştır. Bunlar
bir işi yapabilmek için neler yapılması gerektiğini adım adım anlatan
kısa belgelerdir. Kullanıcıların belge okumak istememeleri ve belgelerin
kısıtlı sayıda senaryoyu kapsaması yüzünden faydalı olamamaktadırlar.<BR>
<BR>
Burda aklımıza, madem bir işi adım adım belgeleyebiliyoruz, bunu bir
program haline getirip otomatik olarak yapılmasını sağlayamaz mıyız?
sorusu gelmektedir. Bu yapılabilirse, kullanıcının zaman tasarrufu
yanında, bu belgelerin çeşitli dillere tercüme edilmesi gibi işler
de gereksiz hale gelecektir.<BR>
<BR>
<!--TOC subsection Diğer Linux Dağıtımları-->

<H3><A NAME="htoc4">2.2</A>&nbsp;&nbsp;Diğer Linux Dağıtımları</H3><!--SEC END -->

Linux dağıtımları gelişme süreçleri içerisinde bu tür entegrasyon
problemleri ile karşılaştıkça bunlara ayrı ayrı çözümler üretip kendi
sistemlerine (özellikle paket yönetici yazılımlarının içine) dahil
etmişlerdir. Bu çözümler, kurulu uygulamalar (menü), fontlar, açılış
işlemleri (initscripts) gibi tek tek alt sistemler bazındadır.<BR>
<BR>
Genellikle, uygulama paketleri, dosya sistemi üzerinde sabit bir dizine,
söz konusu alt sisteme neler sağladıklarını kaydetmekte; bu alt sistemi
kullanacak uygulamalar ise, buraya önceden belirlenmiş biçimde kaydedilen
dosyaları tarayarak, sağlanan hizmetleri bulmaktadır. Uygulamaların
entegrasyonu için, ya uygulamalar buradaki standartları bilecek biçimde
değiştirilmekte, ya da gerekli çevrimi yapacak üçüncü bir yönetici
uygulama araya sokulmaktadır. Kayıt ve çevrim işlemleri için özel
veri biçimleri, kabuk, Perl ya da Python betikleri, bazen de bunların
bir karışımı kullanılmaktadır.<BR>
<BR>
Bir de uygulama kurulur, kaldırılır ve güncellenirken çalışan özel
betikler bulunmaktadır. Bunlarla güncelleme sırasında eski ayarların
taşınması gibi işler yapılmaktadır. Bazı sistemler (örneğin Debian'ın
debconf'u) kurulum anında bu betiklerin kullanıcıya soru sorabilmeleri
ve uygulamayı cevaplara göre ayarlamalarını sağlamaktadır.<BR>
<BR>
Burda gördüğümüz noksanlıklar:
<UL><LI>
Her sorun için ayrı bir çözüm kullanılması benzer işlerin tekrar tekrar
yapılmasına yol açmaktadır. Genel bir ayar profili oluşturmayı ve
yönetmeyi zor kılmaktadır. Birbirleriyle ilişkileri eksik kaldığı
için yeterli entegrasyonu sağlayamamaktadır.
<LI>Yapılandırma ile paket kurulumu iç içe geçmiştir. Bir paket (özellikle
bir sunucu uygulaması) kurulduğunda çalışacak şekilde yapılandırılmasının
yanlış olduğunu, uygulamanın ancak kullanıcı bir emir verdiğinde,
verilen emre göre yapılandırılmasının anlamlı olduğunu düşünüyoruz.
Yapılandırma, kurma ve kaldırma ile ilgisi olmayan ve uygulama sistemde
durduğu sürece her an ihtiyaç duyulabilecek bir iştir.
<LI>Bir sürü veri biçimi ve dil kullanılması, öğrenme ve hata düzeltme
süreçlerini çok güçleştirmektedir.
<LI>Bir sorun çıktığında sistemi çalışabilir bir konuma getirmek, uygulamalar
güncellenirken kullanıcı ayarlarını ve sistemin tutarlılığını korumak
çok zor olabilmektedir.
</UL>
<!--TOC subsection Diğer İşletim Sistemleri-->

<H3><A NAME="htoc5">2.3</A>&nbsp;&nbsp;Diğer İşletim Sistemleri</H3><!--SEC END -->

Windows, OS/2, MacOS X gibi işletim sistemlerinde, sistemin parçaları
ve kullanıcının çalışma ortamını oluşturan uygulamalar genellikle
tek bir merkezden çıktıkları için, uyum sorunları işletim sisteminin
çağrıları (API si) üzerinden çözülmektedir. Ayarları toplu halde tutan
merkezi bir kütük ile birlikte; çokluortam, ağ protokolü, donanım
yöneticisi gibi parçalar için parçaların yerleşebileceği modül yapıları
bulunmaktadır.<BR>
<BR>
Bu yaklaşımda şu noksanlıkları görüyoruz:
<UL><LI>
Uygulamaların ayarlarına merkezi erişim sunulması, tek başına istenen
faydayı getirmemektedir. Bir genel model olmadığı için, bu bilgileri
kullanmak isteyen kullanıcı yada diğer uygulamaların, bilgiyi sunan
uygulama ve ayarları hakkında detaylı bilgiye sahip olması sorunu
hala ortadadır.
<LI>Uygulamalar ve yönetim sistemi arasında API düzeyinde bir ilişki,
iki grubu iç içe geçirip direkt bağlantı sağlayacağı için, parçaların
bağımsızlığını azaltacaktır. Bu da, ayrı ayrı parçaların geliştiricilerinin,
adam/ay modelinde bağımsız çalışmak yerine, bir araya gelip karşılıklı
iletişim ve senkronizasyon ile çalışmasına, dolayısıyla geliştirme
işlerinin ölçeklenebilirliğinin azalmasına yol açmaktadır.
<LI>Parçaların farklı ellerden çıktıkları ve alternatiflerin bol olduğu
özgür yazılım modeline uymamaktadır.
<LI>Dağıtımımıza girecek uygulamaları yeni API leri kullanacak şekilde
değiştirmek, uygulama kodu üzerinde büyük değişiklikler
yapmayı, ve yapılan değişikliklerin yeni sorunlara yol açmadığını
kapsamlı olarak analiz etmeyi gerektirmektedir. Bu da büyük zaman
ve emek harcamasına yol açacaktır. Kodunu değiştirme olanağı olmayan
uygulamaların sisteme entegre edilebilmesini önleyecektir.
<LI>Bu API lerin her uygulamadan kullanılabilmesi ya CORBA, COM gibi karmaşık
çözümler ya da çok sayıda ``wrapper'' gerektirmektedir.
<LI>Bir alt sistemin yetersiz kaldığı görülüp yeni bir alt sistem yapısı
geliştirildiğinde, API değişikliğine yol açmamak için API üzerindeki
değer ve çağrılara kapsamları dışında anlamlar ve görevler yüklenmekte,
ve API yi öğrenmek ve kullanmak isteyenlerin işi çok zorlaşmaktadır.
Ya da API değişikliği yapılmakta, ve varolan uygulamaların yeni API
yi taşınması, eski ve üçüncü parti uygulamalar için uyumluluk katmanları
hazırlanması gibi fazladan sorunlar çıkmaktadır.
</UL>
<!--TOC subsection Özel Yönetim Uygulamaları-->

<H3><A NAME="htoc6">2.4</A>&nbsp;&nbsp;Özel Yönetim Uygulamaları</H3><!--SEC END -->

Linux'un masaüstü ve iş dünyasında kullanımının artmasıyla, bir takım
genel yapılandırma ve yönetim araçları da geliştirilmiştir. YaST,
LinuxConf, WebMin gibi bu araçlar kullanıcıya üst seviye bir arabirim
sunup, kullanıcının burada yaptığı seçimleri uygulamaların alt seviye
ayarlarına taşımaktadır. İki seviye arasında geçiş yapabilmek için
gereken bilgiler araçların içinde bir dizi kural olarak kodlanmıştır.<BR>
<BR>
Bundan başka, bilgisayar ağlarının yaygınlaşmasıyla birlikte, birden
fazla bilgisayarın merkezi yönetimini yapabilecek IBM Tivoli, HP OpenView,
CIM, SNMP, OSI CMIP gibi ürün ve çerçeveler ortaya çıkmıştır. Ayrıntılarda
farkları olmakla birlikte, genel mimarileri, yönetilecek bilgisayarda
bulunacak ajanlar, yönetim bilgisayarında bir yönetici yazılım, bunlar
arasında bir iletişim protokolü ve yönetilecek görev ve ayarları belirten
bilgi modellerinden oluşmaktadır. Yalnızca yapılandırma ile sınırlı
kalmayıp, hata bulma, performans ve güvenlik değerlendirmeleri, kullanım
hesaplama gibi işleri de yapmaktadırlar.<BR>
<BR>
Bu araçlarda gördüğümüz yanlışlar:
<UL><LI>
Üst düzey bir model değil, alt düzey ayarlar yöneticiye sunulmaktadır.
<LI>Yapılandırma problemlerini görev tabanlı değil, uygulama tabanlı ele
almaktadırlar.
<LI>Uygulamalara görevi yaptırmak için gereken bilgi uygulamalarda değil
merkezde (yönetici yazılımın içinde) bulunmaktadır. Bu bilgiler, bir
arada oldukları ve birden fazla parçaya ait detayları içerdikleri
için, öngörülmeyen durumlarda hata ortaya çıkarma ihtimalleri artmaktadır.
</UL>
<!--TOC section Gerekler-->

<H2><A NAME="htoc7">3</A>&nbsp;&nbsp;Gerekler</H2><!--SEC END -->

Bir yapılandırma sisteminin iki müşterisi olacaktır. Biri sistemin
çalışacağı bilgisayardaki kullanıcılar, diğeri ise bu sisteme paket
veya yönetim araçları yapacak olan geliştiricilerdir.<BR>
<BR>
<!--TOC subsection Kullanıcı Gerekleri-->

<H3><A NAME="htoc8">3.1</A>&nbsp;&nbsp;Kullanıcı Gerekleri</H3><!--SEC END -->

<OL type=1><LI>
Yapılandırma sorunları mümkün olduğunda otomatik biçimde çözülmeli,
kullanıcıdan ihtiyacı olmayan teknik detayları bilmesi ve ayarlaması
istenmemelidir.
<LI>Otonom olarak çalışabilmeli, gerektiğinde gömülü sistemlerde de kullanılabilmesi
için grafik arayüzlerden bağımsız olmalıdır.
<LI>Görevler koşutzamanlı (concurrent) çalışmalı, biri diğerini yavaşlatmamalıdır.
<LI>Kullanıcının karar vermesi gereken durumlar kullanıcıya görev tabanlı
bir yaklaşımla ve bilişim okuryazarına yönelik terimlerle sunulmalıdır.
Görev yerine uygulama bazında ayarların sunulması, soruların teknik
detaylara ait terimlerle sorulması istenmemektedir.
<LI>Otomatik yapılacak yapılandırmalar veya kullanıcının yapılandırma
istekleri, sistemi asla iç tutarlılığını kaybetmiş hale getirmemelidir.
Başka bir sebepten bu duruma gelen sistemi tekrar tutarlı hale getirebilmek
mümkün olmalıdır.
<LI>Kullanıcının istekleri farklı adlar altında birer profil olarak gruplanabilmeli,
sistem bir profilden diğerine rahatça geçebildiği gibi, gerektiğinde
bu profiller bir sistemde kaydedilip, diğer bir sisteme taşınabilmelidir.
<LI>Sistem yöneticisi diğer kullanıcılara belirli kriterlere göre yapılandırma
kararı verme yetkisi dağıtabilmelidir. Böylece kullanıcıların gerektiğinde
``kök'' (ing. root) kullanıcı olmadan da sistemin belirli bir
bölümünde (örneğin ağ iletişimi, paket kurulumu, ya da donanım) yapılandırma
ve yönetim yapabilmesi mümkün olacak, kök kullanıcıya olan bağlılık
ortadan kaldırılabilecektir.
</OL>
<!--TOC subsection Geliştirici Gerekleri-->

<H3><A NAME="htoc9">3.2</A>&nbsp;&nbsp;Geliştirici Gerekleri</H3><!--SEC END -->

<OL type=1><LI>
Her yapılandırma problemi için aynı ortak alt yapının kullanılması,
sistemin bir bütün olarak modellenmesi istenmektedir. Bu geliştirme
işlerini kolaylaştıracaktır.
<LI>Uygulamalar, üzerlerinde büyük değişiklikler yapılarak değil, gerekli
yapılandırma bilgisini taşıyan ufak aracılar eklenerek sisteme entegre
edilmelidir.
<LI>Her bir uygulama pakedinin yapılandırma bilgisi tamamen kendi içinde
olmalı, ve tek bir dil ve veri biçimi ile tanımlanmalıdır.
<LI>Yapılandırma sistemi, ilerde ortaya çıkabilecek değişik özellikte
uygulamaların entegrasyonunda sorun çıkartmayacak esnek bir görev
modeline sahip olmalıdır.
<LI>Yapılandırma sistemi ile kurulacak iletişimde dil veya veri biçimi
bağımlılığı problemi olmamalıdır.
<LI>Sistem, kendi ile iletişim kuran uygulamalara, sürekli bir sorma gereksinimi
bırakmadan, bir takım olayların oluştuğunu haber verebilmelidir.
</OL>
<!--TOC section ÇOMAR-->

<H2><A NAME="htoc10">4</A>&nbsp;&nbsp;ÇOMAR</H2><!--SEC END -->

Bu gerekleri sağlayacak bir sistem oluşturabilmek için ilk adım, yapılandırma
sorunlarının tarif edilebileceği bir model oluşturmaktır. Genel olarak
iki tip sorun vardır.<BR>
<BR>
Birinci tip sorunlar iki uygulamanın birbiriyle uyumlu çalışmasının
gerektiği yerlerde çıkarlar. Bunları çözebilmek için her uygulamanın,
<OL type=1><LI>
Diğer uygulamaların bilgilerine erişebilmesini ve kendi bilgilerini
diğer uygulamalara sunabilmesini,
<LI>Önceden belirlenmiş görevler içinden neleri yapabildiğini sisteme
bildirebilmesini,
<LI>Kendi görevleri dışındaki işlere karışmamasını, bunları ilgili uygulamalardan
istemesini,
<LI>Bilgileri değiştiğinde, ilgilenen uygulamaları haberdar edebilmesini
sağlamak gerekir.
</OL>
Böylece uygulamalar kendilerini birbirlerine göre ayarlayabileceklerdir.<BR>
<BR>
İkinci tip sorunlar ise tek bir uygulamanın yapılandırılmasında ortaya
çıkarlar. Aynı görevleri yapabilen uygulamalar fonksiyonel bir sınıf
oluşturmaktadır. Değişen şey, her birinin bu görevi yapmak için farklı
şekilde ayarlanması gerekeceğidir.<BR>
<BR>
Buradan, uygulamaların eş görevleri olan fonksiyonel sınıflar olarak
sınıflandırılabileceği, ve bu sınıflar ortogonal olarak tasarlandığında,
uygulamalar arası yapılandırma problemlerinin çözümü için gereken
şartları sağlayabileceğimiz sonuçlarına varıyoruz.<BR>
<BR>
Ortogonal olarak tasarlanmış sınıflardan oluşan kapsayıcı bir sistem
modeli oluşturduktan sonra, karşımıza modelden istenen görevleri uygulamalara
aktarma sorunu çıkmaktadır.<BR>
<BR>
Uygulamaları bize ait API leri kullanacak biçimde değiştirmek gereklerimize
uygun değildir. Uygulamaların çalışmalarını yönetecek bilgiler ve
ayarlanması gerektiği düşünülen seçenekler genellikle uygulama yazarları
tarafından önceden düşünülüp, bir takım ayar dosyalarından, komut
satırı parametrelerinden, ve benzer yollarla elde edilip kullanılacak
duruma getirilmiştir. O halde en uygun yol, birer aracı programcık
ile modeldeki görevleri, uygulamaların kendi ayar ve komutlarına çevirmektir.<BR>
<BR>
Bu programcıkları bir arada ve düzenli olarak çalıştırabilmek, yapılandırmaları
profiller bazında yönetebilmek, kullanıcılara görevlere erişim yetkisi
verebilmek gibi gerekleri kolayca sağlayabilmek için, bir yönetici
servis programı gerekmektedir.<BR>
<BR>
Yapılandırma grafik arayüzleri, paket yöneticisi, üst düzey yönetim
programları bir iletişim kanalı aracılığı ile bu yönetici programa
bağlanıp, model üzerindeki görevleri kullanabileceklerdir.<BR>
<BR>
Toparlarsak, gereksinimlerimizi karşılayabilecek ve diğer benzer sistemlerdeki
sorunlara düşmeyecek bir yapılandırma yönetim çerçevesi için ihtiyacımız
olan bileşenler, bir sistem modeli, uygulamaları bu modele oturtmak
için gerekli aracı programcıklar ve bu programcıkları işletecek bir
uygulamadır. Şimdi bu bileşenlere detaylı olarak bakalım.<BR>
<BR>
<!--TOC subsection Sistem Modeli-->

<H3><A NAME="htoc11">4.1</A>&nbsp;&nbsp;Sistem Modeli</H3><!--SEC END -->

Sistem modeli, eş görevleri olan uygulamaların fonksiyonel sınıflarından
oluşmaktadır. Burdaki sınıf kavramı, nesne tabanlı programlamadaki
(OOP) sınıf kavramına yakınlık taşıdığından, aynı isimlendirmeleri
kullanmak öğrenme kolaylığı sağlayacaktır.<BR>
<BR>
Buna göre, bir sınıf, bir veya birden fazla uygulamaya ait aracı programcıklar
(nesneler) tarafından sağlanan, ve üzerinde yapılacak görevlere karşılık
gelen metotlar içeren bir tanımlamadır.<BR>
<BR>
Bu nesnelerin, metotlar dışında OOP anlamında özniteliklere sahip
olmaları gerekli görülmemiştir. Bunlar işletilirken sistemin doğası
gereği birer fonksiyon olarak çağrılacak ve tek parametreli bir metottan
farklı olmayacaklardır.<BR>
<BR>
Ayrı yapılandırma problemlerine yönelik olduklarından dolayı, sınıflar
arasında herhangi bir kalıtım (inheritance) ilişkisi yoktur. Bununla
birlikte yakın amaçlara yönelik sınıflar (örneğin iletişimle ilgili
sınıflar, donanım tanımayl ilgili sınıflar, vb) bir grup ismi altında
bir araya toplanmıştır. Grup kavramı, model üzerinde yetki denetimi
tanımlarken kolaylık sağladığı gibi, modeli mantıksal olarak düzenli
tuttuğu için tercih edilmiştir. Bir grup yalnızca, kendine ait sınıfları
bir arada tutar, metot ya da nesneleri yoktur.<BR>
<BR>
Benzer biçimde, aracı programcıklar arasında kod paylaşımı söz konusu
değildir. Bunların ihtiyaç duyacağı ortak yordamlar, API olarak ÇOMAR
tarafından kendilerine sunulacaktır.<BR>
<BR>
Böylece her bir nesne diğerinden yalıtılmış olacağından, nesnelerin
birbirlerinin iç detaylarını bilmesi, ya da başka bir nesneye direk
olarak bağlı olması gibi durumlar oluşmayacaktır.<BR>
<BR>
Her uygulama sağladığı sınıflara ait nesneleri yanında taşır ve kurulum
sırasında ÇOMAR'a kaydeder. Bu nesneler model üzerinde ait oldukları
sınıflara yerleştirilir.<BR>
<BR>
<!--TOC subsubsection İsimlendirmeler-->

<H4>İsimlendirmeler</H4><!--SEC END -->

Model üzerinde gruplar direk adlarıyla gösterilir, sınıflar grup adı
ile birlikte,
<BLOCKQUOTE>
<B>Grup.Sınıf</B>
</BLOCKQUOTE>
biçiminde gösterilirler, her sınıf mutlaka bir grubun içindedir. Sınıf
metotları ise
<BLOCKQUOTE>
<B>Grup.Sınıf.metotAdı</B>
</BLOCKQUOTE>
biçiminde yazılır.<BR>
<BR>
<!--TOC subsubsection Tasarım Kuralları-->

<H4>Tasarım Kuralları</H4><!--SEC END -->

Sistem modeli tasarlanırken bazı noktalara dikkat edilmesi gerekmektedir.
<OL type=1><LI>
Belli uygulamaların değil, bu uygulamaların yaptığı görevlerin yapılandırılması
gözetilmeli, modelin genelliği yitirilmemelidir.
<LI>Modelin gelişen teknolojilerle birlikte eskiyip, kullanışsız hale
gelmemesi için, esnek olması gözetilmelidir.
<LI>Bununla birlikte, ucu açık, tanımlanmamış bilgi ve görevler modele
sokulmamalıdır.
<LI>Burda ayrımı doğru yapabilmek için, görev ve bilgilerin genel kullanıma
mı, yoksa özel kullanıma mı yönelik olduğu bir kriterdir. Bir nesnenin
bir görevi eğer üst katmandaki her nesne tarafından kullanılabiliyorsa
geneldir, açıkça ve kesin olarak tanımlanmalıdır. Eğer görevin kullanımı
sadece özel bir üst nesne tarafından yapılabiliyorsa, özeldir ve bunun
bilgisi tanımlanmaya çalışılmak yerine, üst nesneye hedef olarak verilip,
kendi aralarındaki ilişkileri kendilerinin kurmaları desteklenmelidir.
<LI>Model, kullanıcı ve görev tabanlı tasarlanmakla birlikte, görev uygulamalarının
ihtiyaçlarına yönelik teknik bilgiler de taşıyacaktır. Bu durumların
modelde açıkça belirtilmesi önemlidir.
</OL>
<!--TOC subsection Aracı Programcıklar (CSL)-->

<H3><A NAME="htoc12">4.2</A>&nbsp;&nbsp;Aracı Programcıklar (CSL)</H3><!--SEC END -->

Ne yazık ki basit bir tanımlama dili, görevleri uygulamalara taşımaya
yetmemektedir. Çünkü aracının birçok durumda kendi içinde birden fazla
işlem yapması, çeşitli kriterlere göre işi nasıl yaptıracağına karar
vermesi, gerektiğinde uygulamayı yönetebilmek için, genel API lerin
sağlayabileceğinin dışında fonksiyonlar kullanması gerekmektedir.
İterasyon, karar verme, karşılaştırma, aritmetik ve string işlem yapma
özellikleri olan bir dil gereklidir.<BR>
<BR>
Bu dilin seçimi özgür bırakılabilir, ancak bu durumda yapılandırma
sisteminin bağımlılıkları artmaktadır. En önemlisi diller arası uyum,
hata giderme işlemleri ve öğrenme süreci çok güçleşmektedir. Bu nedenle
tek bir dil kullanılmalıdır.<BR>
<BR>
Genel bir programlama dilinde bulunan çoğu modül ve kitaplık (özellikle
grafik arayüze yönelik olanlar) gerekmeyecektir. Sorun çıkmaması için
dilde bu destekler hiç olmamalı ya da kapatılabilmelidir. İhtiyaç
duyulacak API ler, ayar dosyalarını okuyup yazma, programları çalıştırıp
durdurma gibi işlere yönelik olacaktır.<BR>
<BR>
Bu iş için en uygun dil olarak gördüğümüz Python'u temel aldık. Python
işleticisini (VM), bizim belirlediğimiz bazı modülleri (string, re,
config modülleri, vb...) alıp, bunun üstüne ihtiyacımız olan diğer
fonksiyonları bir modül olarak ekleyerek CSL (Çomar Scripting Language)
adını verdiğimiz bir alt dil oluşturduk. Nedenlerimiz:
<UL><LI>
PİSİ paketlerinin hazırlama ve derleme betiklerinde de Python kullanıldığı
için paket yapıcı tek bir dil öğrenip kullanarak tam bir Pardus pakedi
hazırlayabilecektir.
<LI>Python VM, hız ve kaynak kullanımı olarak çok uygundur. Bir işletici
program içinden rahatça ayarlanıp kullanılabilen bir kitaplık halindedir.
<LI>Program yazarken sıkça karşılaşılan yapıların (design patterns) çoğu
Python'da temel özellik olarak bulunduğu için kod temiz ve anlaşılır
olmakta; implementasyon, mantığı gölgelememektedir.
<LI>Minimal ve temiz sentaksı dolayısıyla kodların boyutu kısa, okunabilirliği
yüksek olmaktadır.
</UL>
<!--TOC subsection Yapılandırma Yöneticisi-->

<H3><A NAME="htoc13">4.3</A>&nbsp;&nbsp;Yapılandırma Yöneticisi</H3><!--SEC END -->

ÇOMAR işletici uygulaması (comard), kullanıcı arayüzleri, ÇOMAR destekli
uygulamalar ve çeşitli araçlardan gelen görev isteklerini sistem modeli
üzerindeki uygulama nesnelerine yaptıran bir sistem servisidir.<BR>
<BR>
Bu istekleri almak, ve olup biten yapılandırma olaylarını bağlanan
uygulamalara aktarabilmek için bir iletişim kanalı gereklidir. ÇOMAR'ın
ön tanımlı iletişim kanalı sistemde sabit bir UNIX soket olmakla birlikte,
yerel bağlantılar için DBus, uzak bağlantılar için HTTP, SSH gibi
protokoller, hatta e-posta ya da SMS gibi iletişim kanalları modüler
olarak kullanılabilir.<BR>
<BR>
Her bir iletişim modülü, ÇOMAR çağrılarını iletmek, ve gelen çağrıların
hangi kullanıcıdan geldiği, iletişim hattının şifreli olup olmadığı,
iletinin elektronik imzayla doğrulanıp doğrulanmadığı gibi bilgilere
bakarak ÇOMAR'ın yetki denetim mekanizmasından geçirmekle sorumludur.
İşletici elindeki nesnelerle sisteme kullanıcı eklemek, alt düzey
ayarları değiştirmek gibi işler yapabilmekte, bunları yapabilmek için
en yüksek yetki seviyesinde çalışmaktadır. Güvenlik açıklarına yol
açmamak için, iletişim modüllerinden gelen isteklerin yetki denetiminden
geçmeden işleticiye geçmesine izin verilmemelidir.<BR>
<BR>
Yetki denetimi çağrıyı yapanın kimlik bilgileri ile, model üzerindeki
her noktada yapılır. Böylece bir kullanıcıya ayar değiştirme yetkisi
vermeden bilgi sorma metotlarını çağırma yetkisi verilebilmesi ya
da bütün bir grubun yönetiminin basitçe tek bir kullanıcıya verilmesi
sağlanabilir.<BR>
<BR>
Görevleri sağlayan nesneler paralel olarak veya çağrı bir nesneye
yönelikse tek olarak işletilir. Bir nesne içinden başka bir sınıfa
yeni bir çağrı yapılabilir. Bir paket kurulduğunda uygulamanın nesnelerini
model kaydettiren, kaldırıldığında çıkaran çağrılar da mevcuttur.<BR>
<BR>
Özellikle açılış esnasında bir sürü işlem yapılmaktadır, bu işlemler
birbirlerinden bağımsız oldukları, aralarındaki bağımlılıklar çok
az olduğu için paralel çalıştırılmaları büyük hız kazancı sağlayacaktır.
İsteklerin paralel yürütülebilmesi, kullanıcının interaktif işlemlerine
çabuk yanıt verebilmek için de önemlidir. Bu amaçla her bir nesne
ayrı bir süreç olarak işletilecektir. Linux'ta yeni bir süreç yaratan
fork çağrısı, bir performans kaybı yaratmayacak kadar hızlı çalışmakta
ve süreçlerin bellek alanları copy-on-write metodu ile çoğaltıldığı
için gereksiz kaynak israfına da yol açmamaktadır.<BR>
<BR>
Yapılandırma işlemleri sistemde sürekli ve sık biçimde yapılmamaktadır.
Yapılacak işler azaldığında ya da iş olmadığında minimum kaynak kullanımına
geçilebilmelidir. Nesnelerin ayrı süreçler olarak işletilmesi bunu
da kolaylaştırmakta, işler hep ana süreç dışında yapıldığı için, bir
iş olmadığında sadece temel takip işlemleri çalışır halde kalmaktadır.<BR>
<BR>
Nesneler belirli bir durumda (bir sistem olayı ya da peryodik zaman
olayları) bir metotlarının çağrılmasını isteyebilirler. ÇOMAR işleticisi
bu istekleri kaydeder ve ilgili olay meydana geldiğinde ilgilenen
nesneleri çağırır.<BR>
<BR>
<!--TOC subsection Kullanıcı Arayüzleri-->

<H3><A NAME="htoc14">4.4</A>&nbsp;&nbsp;Kullanıcı Arayüzleri</H3><!--SEC END -->

ÇOMAR'ı kullanacak en temel uygulama PİSİ'dir. Paketleri kurarken,
pakede ait nesneleri ÇOMAR'a verecek ve uygulamanın sisteme entegre
edilmesini sağlayacaktır. Paket kaldırılırken ise ÇOMAR'a durumu bildirerek
nesnelerin modelden çıkarılmasını sağlar.<BR>
<BR>
Kullanıcının görevleri kullanmasını ve sistemini ayarlayabilmesini
sağlayacak uygulama ise TASMA'dır. Bir grafik arayüzü olan TASMA,
ÇOMAR'daki bilgileri kullanıcıya sunmak, ve kullanıcının emirlerini
ÇOMAR çağrılarına dönüştürmek işlerini yapar.<BR>
<BR>
Bunlar dışında çeşitli arayüzler veya yönetim uygulamaları da ÇOMAR'a
bağlanıp hizmetlerinden yararlanabilir.<BR>
<BR>
<!--TOC section Sıkça Sorulanlar-->

<H2><A NAME="htoc15">5</A>&nbsp;&nbsp;Sıkça Sorulanlar</H2><!--SEC END -->

<!--TOC subsection ÇOMAR'ın açılımı nedir?-->

<H3><A NAME="htoc16">5.1</A>&nbsp;&nbsp;ÇOMAR'ın açılımı nedir?</H3><!--SEC END -->

COnfiguration MAnageR. ÇOMAR'ın açılımı ilk olarak ``Configuration
by Objects, Modify and Restart'' idi. Fakat ÇOMAR'ın tasarım sürecinde
``Modify and Restart'' kısmının ÇOMAR'ın işlevselliğini tam olarak
ifade etmez hale geldiği görüldü ve açılımının ``Configuration
Manager'' olmasının daha doğru ve anlamlı olacağında karar kılındı.<BR>
<BR>
<!--TOC subsection ÇOMAR bana ne fayda sağlayacak?-->

<H3><A NAME="htoc17">5.2</A>&nbsp;&nbsp;ÇOMAR bana ne fayda sağlayacak?</H3><!--SEC END -->

Kurduğunuz uygulamaları elle ayarlamaktan, sistemin zaten bildiği
ve kendi başına bulabileceği bilgileri elle girmekten, bunun için
belge okuyup soru sorarak zaman kaybetmekten kurtulacaksınız.<BR>
<BR>
Sistemin sürekli olarak tutarlı bir durumda kalmasını sağlayarak,
ayar sorunları yüzünden çalışamayan programlardan sizi kurtaracak.<BR>
<BR>
Sunduğu imkanlar ile tek tek uygulama ayarlamaktan ziyade, görev temelli
düşünülmüş grafik arayüzler yazılmasını kolaylaştıracak, bu arayüzler
sayesinde bilgisayara kölelik yapmak yerine kendi işinizle uğraşabileceksiniz.<BR>
<BR>
<!--TOC subsection ÇOMAR desteklemeyen uygulamaları kullanabilecek miyim?-->

<H3><A NAME="htoc18">5.3</A>&nbsp;&nbsp;ÇOMAR desteklemeyen uygulamaları kullanabilecek miyim?</H3><!--SEC END -->

Elbette. Bu uygulamalar ÇOMAR'ın sağladığı avantajlardan faydalanmayacaklar,
ama sistemde çalışabilmelerinin önünde bir engel olmayacak.<BR>
<BR>
<!--TOC subsection Bir uygulamaya ÇOMAR desteği vermek zor mu?-->

<H3><A NAME="htoc19">5.4</A>&nbsp;&nbsp;Bir uygulamaya ÇOMAR desteği vermek zor mu?</H3><!--SEC END -->

Hayır. Bunun için uygulamayı değiştirmenize gerek yok. Yalnızca CSL
ile ÇOMAR modelindeki görevlerin uygulamaya nasıl yaptırılacağını
tarif eden betikler (nesneler) yazmanız yeterli.<BR>
<BR>
<!--TOC subsection CSL yeni bir dil mi?-->

<H3><A NAME="htoc20">5.5</A>&nbsp;&nbsp;CSL yeni bir dil mi?</H3><!--SEC END -->

Aslında hayır. CSL bir Python alt dili. Python'un ihtiyacımız olmayan
modülleri çıkarılıp, bazı yeni modüllerin eklenmesiyle oluşturulmuş,
ve sistem modelimizdeki sınıflara nesne yazmak için kullanılacak hale
getirilmiş hali diyebiliriz. İlk ÇOMAR tasarımı ve prototipinde Javascript/C
arası ve çok kısıtlı bir dil olarak tasarlanmıştı, ama bunun yeterli
gelmediği ve basitlik sağlamadığı görülünce Python temelli olmasına
karar verildi.<BR>
<BR>
<!--TOC subsection ÇOMAR ile PİSİ arasında nasıl bir ilişki var?-->

<H3><A NAME="htoc21">5.6</A>&nbsp;&nbsp;ÇOMAR ile PİSİ arasında nasıl bir ilişki var?</H3><!--SEC END -->

ÇOMAR ve PİSİ, diğer dağıtımlarda bir arada olan kurulum ve yapılandırma
işlerini ayırıyor ve her işi kendi sorumluluk sahası içinde düzgünce
tarif ediyorlar. Birbirlerine ihtiyaç duyduklarında kullanacakları
arabirim ise düzgün bir biçimde tanımlanmış. Böylece temiz ve basit
bir çözüm sağlıyorlar.<BR>
<BR>
<!--TOC subsection ÇOMAR'ı devreden çıkartırsam ne olur?-->

<H3><A NAME="htoc22">5.7</A>&nbsp;&nbsp;ÇOMAR'ı devreden çıkartırsam ne olur?</H3><!--SEC END -->

Otomatik yapılandırma işleri durur, ve ÇOMAR ile çalışan yapılandırma
arayüzleriniz (TASMA) artık çalışmaz. Yani artık kendi başınızasınız
demektir. ÇOMAR'ı yeniden başlatarak bu durumdan kurtulabilirsiniz.<BR>
<BR>
<!--TOC subsection ÇOMAR'ın kconfig, gconf, elektra gibi sistemlerden farkı ne?-->

<H3><A NAME="htoc23">5.8</A>&nbsp;&nbsp;ÇOMAR'ın kconfig, gconf, elektra gibi sistemlerden farkı ne?</H3><!--SEC END -->

Bu sistemler ``configuration'' ismini kullanmalarına rağmen aslen
özel bir veri saklama (storage) sisteminden başka bir şey değildirler.
Uygulama bazında, belirli anahtar kelimelere karşılık gelen verilerin
saklanması ve getirilmesini sağlarlar. Bu anahtarlar sistem çapında
tanımlanmamıştır ve her uygulama için farklıdır. Uygulamaların alt
düzey ayarlarına erişmenizi sağlarlar, ama bir görevi yapmak için
hangi ayarların değişmesi gerektiği, aynı işi yapan farklı bir uygulamanın
bilinmeden nasıl ayarlanabileceği, ayarlar karıştığında sistemin tutarlı
bir hale nasıl getirilebileceği gibi sorunlara bir çözüm getirmezler.<BR>
<BR>
<!--TOC subsection Neden başkaları böyle bir çözüm getirmedi?-->

<H3><A NAME="htoc24">5.9</A>&nbsp;&nbsp;Neden başkaları böyle bir çözüm getirmedi?</H3><!--SEC END -->

Diğer dağıtımlar çözümlerini tarihsel gelişme süreçleri içinde adım
adım geliştirdikleri ve geçmişe uyumluluk yüküyle yollarına devam
ettikleri için bu tür kapsayıcı ve düzenli çözümler getirmeleri zor.
Bir çok yeni girişim ise genel bir model oluşturmayı ihmal ederek,
sorunu bir ayar deposu (configuration storage) olarak ele almaya devam
etmekte.<BR>
<BR>
<!--TOC section Emeği Geçenler-->

<H2><A NAME="htoc25">6</A>&nbsp;&nbsp;Emeği Geçenler</H2><!--SEC END -->

İlk sürüm:<BR>
<BR>
Serdar Köylü, A. Murat Eren, Gürer Özen<BR>
<BR>
Gözden geçirme:<BR>
<BR>
Barış Metin, S. Çağlar Onur, Onur Küçük<BR>
<BR>
İkinci sürüm:<BR>
<BR>
Gürer Özen, Barış Metin, Eray Özkural
</div>
<!-- SAYFA İÇERİK SONU -->
        </div>
    </div>

<!-- yayın hakkı -->

    <div id="footnote">
        <p>
        Pardus sayfalarında bulunan bilgi ve belgelerin, kaynak gösterilmek koşulu ile kullanılması serbesttir.
        <em><br><strong>TÜBİTAK - UEKAE, PK.74 41470, Gebze / Kocaeli.</strong></em>
        Bilgi ve önerileriniz için <a href="mailto:bilgi%20at%20pardus.org.tr">bilgi at pardus.org.tr</a>
        </p>
    </div>
</div>
</body>
</html>

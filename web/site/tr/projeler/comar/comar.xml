<?xml version="1.0" encoding="utf-8" standalone="no"?>

<!DOCTYPE book SYSTEM "http://www.uludag.org.tr/style/uludagbook.dtd"
[
  <!ENTITY projectname "ÇOMAR">
  <!ENTITY longname "Configuration by Objects: Modify And Restart">
]>


<book version="0.1" lang="tr" type="guide">

  <bookinfo>
    <title>&projectname; (&longname;)</title>

    <author author_id="2">
      <firstname>Barış</firstname>
      <lastname>Metin</lastname>
      <address>
        <email>baris@uludag.org.tr</email>
      </address>
    </author>

    <author author_id="2">
      <firstname>Erkan</firstname>
      <lastname>Tekman</lastname>
      <address>
        <email>tekman@uludag.org.tr</email>
      </address>
    </author>

    <pubdate>2004-03-08</pubdate>
    <revhistory>
      <revision author_id="1">
        <revnumber>0.1</revnumber>
	<date>2004-03-05</date>
      </revision>
    </revhistory>

    <abstract>
      <para>
         &projectname;, öncelikli olarak Linux sistemler için tasarlanan bir yapılandırma çerçevesidir. Yapılandırma çerçevesi yapılandırma araçları, paket yönetim sistemi ve diğer çerçevelerin birbirleri arasında bir ayrım katmanı olarak görev yapacaktır.
      </para>
    </abstract>
  </bookinfo>
  
  <chapter>
    <chapterinfo>
      <title>Neden bir "Yapılandırma Çerçevesi"?</title>
      <abstract>
         <para>Bir yapılandırma çerçevesine ihtiyacımız var mı? Göreve yönelimli mevcut yapılandırma süreçlerindeki sorunlar, olası çözüm yolları.
         </para>
      </abstract>
    </chapterinfo>
    
    <sect1>
      <title>Yapılandırma Çerçevesi ne iş yapar?</title>
      <para>
        Yapılandırma çerçevesi basit bir tanım ile <em>yapılandırma araçları</em> ve <em>yapılandırma süreci</em> arasında bir <strong>soyutlama katmanı</strong> olarak düşünülebilir. 
      </para>
      <para>
        Linux/Unix dünyasında yapılandırma süreci genellikle;
        <orderedlist>
          <listitem>Yapılandırma dosyasını düzenle</listitem>
          <listitem>Eğer yapılandırmanın etkin olabilmesi için başka bir servisin/sistemin yapılandırılması gerekiyorsa, bu yapılandırmayı yap</listitem>
          <listitem>Eğer gerekiyorsa yapılandırması dosyaları düzenlenmiş servis(ler)i yeniden başlat/uyar</listitem>
        </orderedlist>
        sürecine dayanıyor.
      </para>
      <para>
        Dolayısı ile yapılandırma sürecini gerçekleştirmek için sistem yöneticilerinin (<em>kimi zaman masaüstü kullanıcıları</em>) iyi bir metin düzenleyiciye sahip olmaları gereği yadırganmayan bir gerçek. Sistemde birbiri ile çalışacak bileşenler birbirlerinden ve sistemin genelinden haberdar olmadıkları için bu süreç kaçınılmaz oluyor.
      </para>
      <para>
        Bu süreç <em>deneyimli kullanıcılar için</em> kabul edilebilir, olabildiğine esnek ve belki de bazıları için ideal yöntem olsa da sistemi yalnızca kullanmak isteyen yeni kullanıcılar için oldukça sancı verici olabiliyor. Sistem yöneticisinin sistemde yaptığı bir değişikliğin istediği gibi uygulayabilmesi için genellikle sistemin geneli hakkında bilgi sahibi olması gerekiyor.
      </para>
      <para>
        Linux/Unix sistemlerin (genel kanı ile) öğrenme eğrisinin yüksek olmasının nedenlerinden bir tanesi de sistemi yapılandırma (bunu sistemi ihtiyaçlara göre özelleştirme olarak dile getirebiliriz) sürecinin uzmanlık gerektirmesi olduğunu söylemek yanlış olmayacaktır.
      </para>
      <para>
        Bu açıdan bakıldığında yapılandırma çerçevesinin sistemin bu karmaşıklığını kullanıcısından gizleyen bir ayırım/soyutlama katmanı olması gereği ortaya çıkıyor. Kullanıcı bir komut verdiğinde, veya grafik arabirimde bir tuşa bastığında işlerin <em>sihirli</em> bir şekilde yapılmasını, son derece haklı nedenler ile, istiyor.
      </para>
    </sect1>
    
    <sect1>
      <title>Var olan çözümler ve olası çözüm yolları!</title>
      <para>
        Yapılandırma sürecindeki ayrıklığı (sistem bileşenlerinin birbirlerinden haberdar olmamaları) sistem kullanıcısından gizleyebilmek için ilk akla gelen ve çalışabilecek yol bu işleri kullanıcıya grafik/metin/web tabanlı bir arayüz ile yaptırmaktır. 
      </para>
      <para>
        Mevcut çözümlerin hemen hepsi de bu <em>basit (!)</em> yöntemi kullanarak yapılandırma araçlarını oluşturuyorlar. Yapılandırma araçları ayrık (redhat-config-*), bütünleşik (Mandrake Control Center, Yast) veya web tabanlı (Webmin) olmasına karşın hepsi aynı yöntem ile karmaşıklığı kullanıcıdan gizlemeyi ilke ediniyor.
      </para>
      <para>
        Buradaki problem yapılandırma araçlarına <em>ayrı ayrı</em> fazla "akıl" yüklenmesi ve yapılandırma araçlarının (daha yetenekli işler yapabileceklerken) kendilerini bir karmaşanın içerisinde bulmaları.
      </para>
      <para>
       Diğer bir çözüm tüm servislerin/sistemlerin kuruldukları anda çalışabilecek şekilde kendilerini yapılandırmaları. Bu defa bir yol ayrımına girmiş oluyorsunuz: Her biri kendi içerisinde problem barındıran iki farklı yöntemden birini seçmeniz gerekiyor.
       <orderedlist>
         <listitem>Ya yapılandırmanız yalnızca öntanımlı bazı kriterler göz önüne alınarak gerçekleştirilecek: esnek yapılandırma seçeneklerini yapılandırma araçlarının içerisine koymak zorunda kalacaksınız ki yukarıdaki sorunlar ile karşılaşmış olacağız.</listitem>
         <listitem>Ya da kurulum sırasında kullanıcı ile etkileşimli çalışacaksınız (Debian/Debconf): Kurulum işlemini güçleştireceksiniz.</listitem>
       </orderedlist>
     </para>
     <para>
       Her iki yöntem ile de, paket yönetimi sistemini ve paketleri ayrı ayrı gereğinden fazla karmaşıklaştırmış olacaksınız.
     </para>
     <para>
       Akla gelebilecek ideal çözüm sisteme bileşen olarak eklediğiniz yazılımları, <strong>zaten bir bütünün parçaları olarak geliştirmek</strong> olabilir. Bu yöntem ile tüm yazılımların bizim tarafımızdan tanımlanmış kurallar çerçevesinde gerçekleşmesini öngörüyoruz. Bu sayede tüm sistem bileşenleri için yapılandırma süreci <em>özdeş</em> olabilir ve yapılandırma araçları her bileşen için ayrı ayrı hareket etmek zorunda kalmaz. Hatta tek noktadan erişilebilir olabilir. Yalnız bu tek noktayı sağlayabilmek için yine bir yapılandırma/yönetim çerçevesi tanımlamak gerekir.
     </para>
     <para>
       Fakat bu son yöntem özgür yazılım kültüründe kullanılabilecek bir seçenek olarak <strong>durmuyor</strong>. Özgür yazılımlar üzerinde (tek bir noktadan) söz sahibi olmak mümkün olmadığı gibi istenmeyen de bir yöntemdir. Bu tarz <em>standartlaşma</em> çalışmaları bağımsız organizasyonlar tarafından yürütülüyor. Freedesktop masaüstü ortamlarının standartlarının belirlenmesi konusunda çalışıyor, fakat sistem genelinde bu tür bir çalışma olmadığı gibi tüm sistemlerin bu standartlara %100 uymasını sağlamak uzun bir zaman alacaktır.
     </para>
    </sect1>

  </chapter>

  <chapter>
     <chapterinfo>
       <title>Uludağ'ın çözüm önerisi: &projectname;</title>
       <abstract>
         <para><graphic source="/img/comar/comar.png" align="bottom"/> &projectname; (&longname;) bizim bu <strong>soyutlama katmanı</strong> çerçevesine verdiğimiz isim. Soyutlama katmanının ana görevi sistem genelindeki karmaşıklığı yapılandırma araçlarından gizlemek olarak özetlenebilir. Bu tarz bir soyutlamanın yapılandırma araçlarına yeni yetenekler kazandıracağı da görülmektedir.</para>
       </abstract>
     </chapterinfo>

     <sect1>
       <title>Tasarım</title>
       <para>
         Tasarımı şekiller üzerinden örnek bir senaryo ile açıklamaya çalışalım.
       </para>
       <para>
         <graphic source="/img/comar/VH1_present.png" align="bottom"/>
       </para>
       <para>
         Birinci şekil klasik yapılandırma sürecini gösteriyor. Bir metin düzenleyici ile yapılandırma dosyasını düzenleniyor ve servis yeni yapılandırmadan haberdar ediliyor. Bu şekil ile yalnızca klasik yapılandırma sürecini özetlemeyi amaçladık.
       </para>
       <para>
         Şimdi &projectname;'ın devrede olduğu bir yapılandırma sürecini gözlemlemeye çalışalım:
       </para>
       <para>
         <graphic source="/img/comar/VH2_request.png" align="bottom"/>
       </para>
       <para>
         Yapılandırma aracı (şekildeki <em>GUI</em>) yapılandırma isteğini <em>interface</em> olarak adlandırılan &projectname;-API üzerinden &projectname; çekirdeğine gönderiyor. <strong>Burada ve diğer adımlarda aradaki haberleşme bir nesne içerisinde saklanmış <em>soru/cevaplar</em> olarak veya üzerinde anlaşılmış bir protokol vasıtası ile olabilir</strong>
       </para>
       <para>
         <graphic source="/img/comar/VH3_search.png" align="bottom"/>
       </para>
       <para>
         &projectname; çekirdeği yapılandırma saklayıcısı (conf storage) ile konuşarak sistem geneline dair bilgileri alıyor.
         <orderedlist>
           <listitem>Yapılandırma için gerekli bileşenlere sahip miyim?</listitem>
           <listitem>Bu yapılandırmadan kim sorumlu?</listitem>
           <listitem>Başka nelere ihtiyacım var?</listitem>
         </orderedlist>
       </para>
       <para>
         <graphic source="/img/comar/VH4_objects.png" align="bottom"/>
       </para>
       <para>
         &projectname; çekirdeği nesne havuzundan gerekli nesneleri buluyor ve ihtiyaç duyduğu bilgileri alıyor. Burada <em>webserver</em> nesnesi ile haberleşilerek <em>apache</em> nesnesine yönlendiriliyor, ve <em>apache</em> nesnesinden gerekli bilgiler alınıyor.
       </para>
       <para>
         <graphic source="/img/comar/VH5_configure.png" align="bottom"/>
       </para>
       <para>
         <em>apache</em> nesnesinden alınan bilgiler ile yapılandırma saklayıcısı (conf storage) güncelleniyor.
       </para>
       <para>
         <graphic source="/img/comar/VH6_objects2.png" align="bottom"/>
       </para>
       <para>
         Yapılandırma için ihtiyaç duyulan bir diğer nesne <em>nameserver</em> nesnesi. Bu nesne ile de benzer bir şekilde haberleşilerek <em>DNS (Bind)</em> nesnesine ulaşılıyor.
       </para>
       <para>
         <graphic source="/img/comar/VH7_configure2.png" align="bottom"/>
       </para>
       <para>
         Eğer <em>DNS</em> servisi de yerel bir servis ise <em>apache</em> örneğinde olduğu gibi süreç tekrarlanıyor. Eğer (resimde olduğu gibi) yerel bir servis değil ise <em>DNS</em> servisinden alınan bilgiler ile güncellenmesi gereken alan adı kayıtları uzak sistem çağrıları (RPC) ile güncellenilmeye çalışılıyor.
       </para>
       <para>
         <graphic source="/img/comar/VH8_parsestore.png" align="bottom"/>
       </para>
       <para>
         Yapılandırmalar saklama alanından alınarak <em>conf parser</em> aracılığı ile <em>apache</em> yapılandırma dosya(lar)ına saklanıyor.
       </para>
       <para>
         <graphic source="/img/comar/VH9_restart.png" align="bottom"/>
       </para>
       <para>
         Ve apache servisi uyarılarak değişikliğin aktif olması sağlanıyor.
       </para>
         
     </sect1>
     <sect1>
       <title>Tasarımın Getirileri</title>
       <para>
         Kısaca getirileri maddeler ile özetlemeye çalışalım.
         <orderedlist>
           <listitem>Soyutlanmış bir sistem ile yapılandırma araçları sistemin karmaşıklığı ile ilgilenmek zorunda kalmayacaklar.</listitem>
           <listitem>Bir sıradüzen ile ortak bir yapılandırma saklama alanında tutulan yapılandırma seçeneklerini yönetmek kolaylaşacaktır. Yapılandırma seçeneklerini diğer makinelere aktarmak, saklayabilmek, başka servislerde kullanmak kolaylaşacaktır.</listitem>
           <listitem>Yapılandırma seçenekleri yerelde saklanabileceği gibi uzaktaki bir alanda da saklanabilecektir. &projectname; Config belli yapılandırma seçeneklerini yerelden, ağ genelindeki yapılandırma seçeneklerini uzaktaki bir saklama alanından alabilir.</listitem>
         </orderedlist>
       </para>
     </sect1>

 </chapter>

	   
</book>

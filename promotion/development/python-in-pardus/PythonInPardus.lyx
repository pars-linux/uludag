#LyX 1.4.1 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass article
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Title
Python in Pardus
\end_layout

\begin_layout Author
Gürer Özen
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
what is pardus
\end_layout

\begin_layout Standard
some background: aims, manpower, turkish free software community
\end_layout

\begin_layout Standard
choice of python, our learning process
\end_layout

\begin_layout Section
Package Management
\end_layout

\begin_layout Standard
Package management is the key part of a software distribution.
 Users expect it to work robustly and automatically.
 Packagers want to package their software without going through complex
 build procedures.
 Developers want to quickly deploy their patches to the users.
 Distribution maintainers want automated tools for validating, analysing
 and building the software collection.
 Finally third parties want to embed and extend core distribution into their
 own specialized releases.
\end_layout

\begin_layout Standard
Our custom package management system PiSi is designed to meet those requirements.
 Here we are going to discuss involment of the Python.
 You can find more information about general design in the PiSi article
\begin_inset LatexCommand \cite{key-18}

\end_inset

.
\end_layout

\begin_layout Subsection*
Package Specification
\end_layout

\begin_layout Standard
Package is a collection of files and some meta information about what is
 the contained software, how is it going to be installed, and what are its
 requirements (dependencies).
 A binary package is usually build from a specification which describes
 the original source, added patches by the distribution, and build instructions.
 We keep those specifications inside a subversion repo, one directory per
 package, neatly organized in the component directories.
\end_layout

\begin_layout Standard
Since specification contains both data (like software name, its homepage,
 version, description, license, location of the original source, list of
 the patches, etc) and programs (build instructions, install instructions,
 remove instructions, etc), we decided to keep those separate.
 That way, parsing and using data becomes really easy.
\end_layout

\begin_layout Standard
Avoiding new ad-hoc formats, and keeping everything simple as it can be,
 we decided to put data into an XML file.
 Data is very structured, and some items (like description) have translated
 versions as well, so everything fits nicely in the XML format.
\end_layout

\begin_layout Standard
Deciding about programs was harder.
 Ideally all programs (build, install, remove scripts) should be written
 in same language.
 Packager only has to know one language, and maintainance becomes a lot
 easier.
\end_layout

\begin_layout Standard
Traditionally build scripts were shell scripts.
 Shell is ideal for simple tasks requiring batch run of a series of commands.
 Unfortunately there are cases where you need conditional operations, do
 string processing, and iterate an operation over a series of data.
 In those cases shell syntax becomes awkward, debugging and maintainance
 costs go higher.
\end_layout

\begin_layout Standard
In simplest case of build operation (configure; make), there isn't much
 difference between alternative languages.
 But when cases get more complex, you'll definitely want a language with
 rich set of datatypes, native support for strings, clean and concise syntax,
 and a standart library with a wide range of useful functions.
 This language shouldn't have a steep learning curve, and shouldn't look
 too different from shell scripts or shouldn't require a complete paradigm
 change for system admins and packagers (like some pure functional languages).
\end_layout

\begin_layout Standard
We decided that Python succesfully meets these requirements, and is the
 best choice for package scripts.
\end_layout

\begin_layout Subsection*
Build Scripts
\end_layout

\begin_layout Standard
After coding a proof of concept package manager, we started making packages.
 In a six months of time, with a six people, we managed to make packages
 of base system (kernel, drivers, glibc, gcc, gnu tools), desktop (xorg,
 KDE), and applications (Gimp, TeTeX, K3B, mplayer, OpenOffice.org, etc).
 There were a total of 600 packages which are bootstrapped and build on
 a Pardus system.
 Now a year after, we have 1227 packages in our official repository
\begin_inset LatexCommand \cite{key-19}

\end_inset

, and 698 packages in an extra contribution repository
\begin_inset LatexCommand \cite{key-20}

\end_inset

, made by 25 developers.
\end_layout

\begin_layout Standard
In the official repository, there are 32641 lines (where 8044 of them are
 comment lines) of Python code for packages.
 Script for one of the simple packages, gparted, is given below:
\end_layout

\begin_layout LyX-Code
#!/usr/bin/python
\end_layout

\begin_layout LyX-Code
# -*- coding: utf-8 -*-
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code
# Copyright 2005, 2006 TUBITAK/UEKAE
\end_layout

\begin_layout LyX-Code
# Licensed under the GNU General Public License, version 2.
\end_layout

\begin_layout LyX-Code
# See the file http://www.gnu.org/copyleft/gpl.txt.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
from pisi.actionsapi import autotools
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
def setup():
\end_layout

\begin_layout LyX-Code
    autotools.configure()
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
def build():
\end_layout

\begin_layout LyX-Code
    autotools.make()
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
def install():
\end_layout

\begin_layout LyX-Code
    autotools.install() 
\end_layout

\begin_layout Standard
As you see, there isn't much in this script, everything is handled by the
 autotools module.
 A generic utility module and a few such build system modules (for autotools,
 scons, cmake, perl and python extensions) are provided by package manager
 (in the pisi.actionsapi package).
 Stages of the build process are represented by three Python functions.
\end_layout

\begin_layout Standard
Here is another slightly complex example function from the LyX package:
\end_layout

\begin_layout LyX-Code
def setup():
\end_layout

\begin_layout LyX-Code
    viewers = { 'PDF': 'kpdf',
\end_layout

\begin_layout LyX-Code
                'PS': 'kghostview',
\end_layout

\begin_layout LyX-Code
                'DVI': 'kdvi',
\end_layout

\begin_layout LyX-Code
                'HTML': 'konqueror' }
\end_layout

\begin_layout LyX-Code
    for k in viewers:
\end_layout

\begin_layout LyX-Code
        shelltools.export(k + '_VIEWER', viewers[k])
\end_layout

\begin_layout LyX-Code
    autotools.configure("--with-frontend=qt")
\end_layout

\begin_layout Standard
As you see, some defaults are modified via environment variables before
 configuring.
\end_layout

\begin_layout Standard
There aren't many complex build scripts.
 Most of the logic and error checking is handled by provided utility modules
 (ActionsAPI).
 Scripts requiring complex operations and interactions are managed by our
 configuration management system Comar.
 PiSi merely passes those scripts to the Comar.
 Examples of them are given in the system configuration section of this
 article.
\end_layout

\begin_layout Subsection*
Package Manager
\end_layout

\begin_layout Standard
PiSi itself is written in Python too.
 This is a huge deviation from other well known package management software
 (Redhat's rpm or Debian's dpkg which are both written in C).
\end_layout

\begin_layout Standard
PiSi architecture is quite different from traditional designs.
 Every functionality, related to the package management like installing,
 building, fetching, dependency solving, repository management, validating
 is included in the core (compare with dpkg, apt-get or rpm, urpmi separation).
 PiSi can work with both binary repositories, and source packages like Gentoo's
 portage.
 On the other hand, package configuration (like calling ldconfig, modifying
 global configuration files, etc) is delegated to Comar.
\end_layout

\begin_layout Standard
PiSi source
\begin_inset LatexCommand \cite{key-21}

\end_inset

 is 14245 lines of Python code distributed in 72 modules in 6 packages.
 Command line driver (pisi command) is just a simple frontend to all those
 modules.
 They can also be used together or partially by other programs.
 There are also a few more scripts, and a comprehensive test suite containing
 both unit tests, and full scenario tests.
\end_layout

\begin_layout Standard
An example test senario (scenarios/bug3481scen.py in PiSi source) is like
 this:
\end_layout

\begin_layout LyX-Code
from pisi.scenarioapi.scenario import *
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
HASHALOT="hashalot"
\end_layout

\begin_layout LyX-Code
COREUTILS="coreutils"
\end_layout

\begin_layout LyX-Code
GLIBC="glibc"
\end_layout

\begin_layout LyX-Code
UTIL_LINUX="util-linux"
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
let_repo_had(HASHALOT, with_partof("system.base"))
\end_layout

\begin_layout LyX-Code
let_repo_had(COREUTILS, with_partof("system.base"))
\end_layout

\begin_layout LyX-Code
let_repo_had(GLIBC, with_partof("system.base"))
\end_layout

\begin_layout LyX-Code
let_repo_had(UTIL_LINUX, with_partof("system.base"))
\end_layout

\begin_layout LyX-Code
let_pisi_had(COREUTILS, HASHALOT, GLIBC, UTIL_LINUX)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
def run():
\end_layout

\begin_layout LyX-Code
    repo_version_bumped(GLIBC)
\end_layout

\begin_layout LyX-Code
    repo_version_bumped(UTIL_LINUX)
\end_layout

\begin_layout LyX-Code
    repo_version_bumped(COREUTILS, with_added_conflicts(HASHALOT))
\end_layout

\begin_layout LyX-Code
    repo_updated_index()
\end_layout

\begin_layout LyX-Code
    pisi_upgraded() 
\end_layout

\begin_layout Standard
It is as readable as pseudo code, yet it works too.
\end_layout

\begin_layout Standard
A package management software deals a lot with sets, lists, and dependency
 graphs.
 Python has former two natively, and implementing latter is very simple
 with available primitives.
 Object oriented nature of Python, with module and package concepts, kept
 the code very modular and good structured.
 We have used functional operators (map, filter, reduce) and list comprehensions
 a lot.
 Even metaclasses are used in a few places.
\end_layout

\begin_layout Standard
An other reason to choose Python was its standart library.
 Although some parts of it (xml modules) are extremely slow and hard to
 use, and some parts (os, shutil, zipfile) needs a few wrappers to get it
 right, we have used quite a number of standart modules (like cPickle, re,
 unittest, subprocess, getopt, gettext, zlib, bz2, tarfile, urllib2, urlparse,
 sha).
 More information about our problems with the standart library can be found
 in problems section of this article.
 But all in all, they helped greatly by allowing us to reuse already tested
 components instead of writing everything from scratch.
\end_layout

\begin_layout Standard
We have only encountered a speed problem with XML parsing, which we solved
 by first migrating to 4suite parser, then our custom module.
 Currently there is a slowness only within certain database operations,
 but that is mostly caused by suboptimal use of BerkeleyDB, and will be
 fixed in the next major release.
 Most of the PiSi work is bounded by disc IO, and heavy calculation parts
 like dependency solving work really fast, if carefully coded by using as
 much as builtin functions of the Python.
\end_layout

\begin_layout Standard
A reason to code in C could be that you can statically compile everything
 into an executable, and run that even if every library in the system is
 broken.
 That is a trade-off, we decided to make.
 Currently PiSi depends on a minimal Python installation (with its library,
 and a few of modules), BerkeleyDB, piksemel (our XML python module) and
 glibc.
 Since those packages are required for operation, PiSi takes extra care
 while updating them.
\end_layout

\begin_layout Subsection*
User Interfaces
\end_layout

\begin_layout Standard
Main desktop environment of the Pardus is KDE.
 Python bindings
\begin_inset LatexCommand \cite{key-22}

\end_inset

 of the KDE are highly maintained and very comprehensive.
 Every component of the desktop, be it an application, a control center
 module, an IO handler module, or a panel applet, can be written in Python.
 Similarly you can use almost any component like khtml from Python.
\end_layout

\begin_layout Standard
Graphical user interface of the PiSi is 2558 lines of Python code.
 This includes both a control center module, and a panel applet for regularly
 checking repositories and showing available updates.
\end_layout

\begin_layout Standard
(burada package-manager ekran görüntüsü)
\end_layout

\begin_layout Standard
Another application using PiSi is Pardusman, a tool for making release media.
 You can select packages from a binary repository and easily make a live
 or install CD with a few clicks.
 It is 1481 lines of Python code.
\end_layout

\begin_layout Standard
(burada pardusman ekran görüntüsü)
\end_layout

\begin_layout Standard
As you see, PiSi user interfaces are very short, yet quite capable programs.
 Coding in Python saves quite a bit of boiler plate code when compared to
 C++.
 Subclassing a window is just a 
\family typewriter
class MyWindow(QMainWindow)
\family default
 line for example.
\end_layout

\begin_layout Section
System Configuration
\end_layout

\begin_layout Standard
Configuring software and hardware is the most boring task, a user can do
 with a computer.
 Installing a program can require setting up some system variables.
 If you want to connect to the Internet, you have to set up some options
 of the network interface device, maybe even run some programs to handle
 the connection.
 Your hardware needs some kernel modules loaded, and some programs run to
 start operating.
 You may need to edit your xorg.conf file to be able to use native resolution
 of your LCD.
\end_layout

\begin_layout Standard
Hopefully most of these tasks can be automated, and other can be greatly
 simplified.
\end_layout

\begin_layout Standard
Our configuration framework Comar is designed to do that.
 Explaining all the details needs a separate article.
 We are going to layout only the general architecture here.
 So, basically,
\end_layout

\begin_layout Itemize
Configuration tasks are defined in a system model, grouped by classes which
 contain related tasks.
\end_layout

\begin_layout Itemize
Each software package can carry small configuration scripts for these classes.
\end_layout

\begin_layout Itemize
A class can be provided by different packages, also a package can provide
 different classes.
\end_layout

\begin_layout Itemize
When you call a configuration task, configuration script drives the package
 to do this job, by modifying its configuration file, sending signals, calling
 commands or using whatever mechanism is necessary.
\end_layout

\begin_layout Itemize
You can ask a task from a specific package, anyone who can do that job,
 or everyone providing that class.
\end_layout

\begin_layout Itemize
There is a daemon who keeps registered classes, listens for configuration
 calls, and runs the scripts.
\end_layout

\begin_layout Itemize
This daemon handles access control, so you can delegate some configuration
 permissions to normal users.
\end_layout

\begin_layout Standard
(buraya basit bir sema koy)
\end_layout

\begin_layout Standard
This architecture has quite a number of advantages.
 What we are interested here is that the actual logic of the configuration
 tasks are carried within package scripts.
 That way, packages are well encapsulated, different versions can have different
 ways of doing same tasks.
\end_layout

\begin_layout Standard
Theorically these scripts could be in any language.
 But there are many practical problems with that.
 Maintainance becomes harder with a big repository with scripts written
 in all sorts of languages.
 Function calling and parameter passing needs to be implemented for all
 those languages.
\end_layout

\begin_layout Standard
Since we already used Python in build scripts, also using it in configuration
 scripts came up as a natural choice.
 Several advantages are,
\end_layout

\begin_layout Itemize
Packagers need to know only one language,
\end_layout

\begin_layout Itemize
Comprehensive standart library with a wide range of extensions is available
 to use in scripts,
\end_layout

\begin_layout Itemize
Every feature of the Python is accessible and controllable from the Python
 C library,
\end_layout

\begin_layout Itemize
Scripts can be called by all users.
 They must have permission to make the call beforehand, but since script
 itself runs with a higher privilege, an interpreted language with garbage
 collection is very helpful against buffer overflow type attacks caused
 by malformed parameters from users.
\end_layout

\begin_layout Standard
Comar daemon
\begin_inset LatexCommand \cite{key-23}

\end_inset

 listens configuration requests and, if user has permission to do that,
 forks a job process for each call.
 This job process loads up package script and run it.
 That way configuration operations can run in parallel, and self contained.
\end_layout

\begin_layout Standard
We first tried to write this daemon in Python too, but changed to C later.
 Reason is that daemon is very small (6216 lines of C code) and very low
 level, there isn't much to gain from Python.
 Since Python interpreter is not even initialized in main process, resource
 usage is very low when there isn't a configuration job is running.
\end_layout

\begin_layout Standard
(comar api anlat)
\end_layout

\begin_layout Subsection*
Boot Subsystem
\end_layout

\begin_layout Subsection*
Hardware Probing
\end_layout

\begin_layout Subsection*
Network Subsystem
\end_layout

\begin_layout Subsection*
Package Configuration
\end_layout

\begin_layout Section
Applications and Scripts
\end_layout

\begin_layout Standard
yali
\end_layout

\begin_layout Standard
kcontrol modules
\end_layout

\begin_layout Standard
buildfarm?
\end_layout

\begin_layout Standard
repostats
\end_layout

\begin_layout Standard
ismail.py
\end_layout

\begin_layout Standard
ivir zivir
\end_layout

\begin_layout Section
Custom Modules
\end_layout

\begin_layout Standard
piksemel
\end_layout

\begin_layout Standard
catbox
\end_layout

\begin_layout Standard
pyaspects
\end_layout

\begin_layout Section
Problems
\end_layout

\begin_layout Standard
https://sourceforge.net/tracker/?func=detail&aid=1507247&group_id=5470&atid=30547
0
\end_layout

\begin_layout Standard
https://sourceforge.net/tracker/index.php?func=detail&aid=1513206&group_id=5470&at
id=305470
\end_layout

\begin_layout Standard
https://sourceforge.net/tracker/index.php?func=detail&aid=1509889&group_id=5470&at
id=305470
\end_layout

\begin_layout Standard
https://sourceforge.net/tracker/?func=detail&atid=105470&aid=1336623&group_id=547
0
\end_layout

\begin_layout Standard
http://tinyurl.com/y4bwf5
\end_layout

\begin_layout Standard
http://tinyurl.com/twkns
\end_layout

\begin_layout Standard
https://sourceforge.net/tracker/index.php?func=detail&aid=1056231&group_id=5470&at
id=305470
\end_layout

\begin_layout Standard
https://sourceforge.net/tracker/index.php?func=detail&aid=1454485&group_id=5470&at
id=305470
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
evaluation of python:
\end_layout

\begin_layout Standard
-rapid development
\end_layout

\begin_layout Standard
-speed
\end_layout

\begin_layout Standard
-i18n
\end_layout

\begin_layout Standard
-learning curve (for developers, and outside packagers)
\end_layout

\begin_layout Standard
-standart library
\end_layout

\begin_layout Standard
-bugs
\end_layout

\begin_layout Standard
final word
\end_layout

\begin_layout Bibliography

\bibitem {key-18}
Pisi makalesi
\end_layout

\begin_layout Bibliography

\bibitem {key-19}
Official package repository
\end_layout

\begin_layout Bibliography

\bibitem {key-20}
Contrib package repository
\end_layout

\begin_layout Bibliography

\bibitem {key-21}
Pisi kodlari
\end_layout

\begin_layout Bibliography

\bibitem {key-22}
PyQt PyKDE
\end_layout

\begin_layout Bibliography

\bibitem {key-23}
Comar daemon kodu
\end_layout

\end_body
\end_document

#LyX 1.5.0beta1 created this file. For more info see http://www.lyx.org/
\lyxformat 262
\begin_document
\begin_header
\textclass article
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "Gürer Özen" 
\end_header

\begin_body

\begin_layout Title
Python in Pardus
\end_layout

\begin_layout Author
Gürer Özen
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Python is a dynamic object-oriented programming language that can be used
 for many kinds of software development.
 At least, that it what its homepage says.
 It is actually used by a range of companies from Google to Firaxis Games
\begin_inset LatexCommand cite
key "key-6"

\end_inset

 in many different areas.
 Some Linux distributions use it for developing their tools, mostly user
 interfaces.
\end_layout

\begin_layout Standard
It is used almost everywhere in Pardus.
 From startup system to user interfaces.
 This wasn't intentional.
 We started using Python in a few places for rapid development, and then
 it spreaded to other areas.
 Also most of the core developers learned Python after joining the project.
\end_layout

\begin_layout Standard
In this report, we are giving a summary of our Python experience, how it
 is used in Pardus GNU/Linux distribution, and what sort of problems encountered.
\end_layout

\begin_layout Section
Package Management
\end_layout

\begin_layout Standard
Package management is the key part of a software distribution.
 Users expect it to work robustly and automatically.
 Packagers want to package their software without going through complex
 build procedures.
 Developers want to quickly deploy their patches to the users.
 Distribution maintainers want automated tools for validating, analysing
 and building the software collection.
 Finally third parties want to embed and extend core distribution into their
 own specialized releases.
\end_layout

\begin_layout Standard
Our custom package management system PiSi is designed to meet those requirements.
 Here we are going to discuss involment of the Python.
 You can find more information about general design in the PiSi article
\begin_inset LatexCommand cite
key "key-5"

\end_inset

.
\end_layout

\begin_layout Subsection*
Package Specification
\end_layout

\begin_layout Standard
Package is a collection of files and some meta information about what is
 the contained software, how is it going to be installed, and what are its
 requirements (dependencies).
 A binary package is usually build from a specification which describes
 the original source, added patches by the distribution, and build instructions.
 We keep those specifications inside a subversion repo, one directory per
 package, neatly organized in the component directories.
\end_layout

\begin_layout Standard
Since specification contains both data (like software name, its homepage,
 version, description, license, location of the original source, list of
 the patches, etc) and programs (build instructions, install instructions,
 remove instructions, etc), we decided to keep those separate.
 That way, parsing and using data becomes really easy.
\end_layout

\begin_layout Standard
Avoiding new ad-hoc formats, and keeping everything simple as it can be,
 we decided to put data into an XML file.
 Data is very structured, and some items (like description) have translated
 versions as well, so everything fits nicely in the XML format.
\end_layout

\begin_layout Standard
Deciding about programs was harder.
 Ideally all programs (build, install, remove scripts) should be written
 in same language.
 Packager only has to know one language, and maintainance becomes a lot
 easier.
\end_layout

\begin_layout Standard
Traditionally build scripts were shell scripts.
 Shell is ideal for simple tasks requiring batch run of a series of commands.
 Unfortunately there are cases where you need conditional operations, do
 string processing, and iterate an operation over a series of data.
 In those cases shell syntax becomes awkward, debugging and maintainance
 costs go higher.
\end_layout

\begin_layout Standard
In simplest case of build operation (configure; make), there isn't much
 difference between alternative languages.
 But when cases get more complex, you'll definitely want a language with
 rich set of datatypes, native support for strings, clean and concise syntax,
 and a standart library with a wide range of useful functions.
 This language shouldn't have a steep learning curve, and shouldn't look
 too different from shell scripts or shouldn't require a complete paradigm
 change for system admins and packagers (like some pure functional languages).
\end_layout

\begin_layout Standard
We decided that Python succesfully meets these requirements, and is the
 best choice for package scripts.
\end_layout

\begin_layout Subsection*
Build Scripts
\end_layout

\begin_layout Standard
After coding a proof of concept package manager, we started making packages.
 In a six months of time, with a six people, we managed to make packages
 of base system (kernel, drivers, glibc, gcc, gnu tools), desktop (xorg,
 KDE), and applications (Gimp, TeTeX, K3B, mplayer, OpenOffice.org, etc).
 There were a total of 600 packages which are bootstrapped and build on
 a Pardus system.
 Now a year after, we have 1227 packages in our official repository
\begin_inset LatexCommand cite
key "key-19"

\end_inset

, and 698 packages in an extra contribution repository
\begin_inset LatexCommand cite
key "key-20"

\end_inset

, made by 25 developers.
\end_layout

\begin_layout Standard
In the official repository, there are 32641 lines (where 8044 of them are
 comment lines) of Python code for packages.
 Script for one of the simple packages, gparted, is given below:
\end_layout

\begin_layout LyX-Code
#!/usr/bin/python
\end_layout

\begin_layout LyX-Code
# -*- coding: utf-8 -*-
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code
# Copyright 2005, 2006 TUBITAK/UEKAE
\end_layout

\begin_layout LyX-Code
# Licensed under the GNU General Public License, version 2.
\end_layout

\begin_layout LyX-Code
# See the file http://www.gnu.org/copyleft/gpl.txt.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
from pisi.actionsapi import autotools
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
def setup():
\end_layout

\begin_layout LyX-Code
    autotools.configure()
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
def build():
\end_layout

\begin_layout LyX-Code
    autotools.make()
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
def install():
\end_layout

\begin_layout LyX-Code
    autotools.install() 
\end_layout

\begin_layout Standard
As you see, there isn't much in this script, everything is handled by the
 autotools module.
 A generic utility module and a few such build system modules (for autotools,
 scons, cmake, perl and python extensions) are provided by package manager
 (in the pisi.actionsapi package).
 Stages of the build process are represented by three Python functions.
\end_layout

\begin_layout Standard
Here is another slightly complex example function from the LyX package:
\end_layout

\begin_layout LyX-Code
def setup():
\end_layout

\begin_layout LyX-Code
    viewers = { 'PDF': 'kpdf',
\end_layout

\begin_layout LyX-Code
                'PS': 'kghostview',
\end_layout

\begin_layout LyX-Code
                'DVI': 'kdvi',
\end_layout

\begin_layout LyX-Code
                'HTML': 'konqueror' }
\end_layout

\begin_layout LyX-Code
    for k in viewers:
\end_layout

\begin_layout LyX-Code
        shelltools.export(k + '_VIEWER', viewers[k])
\end_layout

\begin_layout LyX-Code
    autotools.configure("--with-frontend=qt")
\end_layout

\begin_layout Standard
As you see, some defaults are modified via environment variables before
 configuring.
\end_layout

\begin_layout Standard
There aren't many complex build scripts.
 Most of the logic and error checking is handled by provided utility modules
 (ActionsAPI).
 Scripts requiring complex operations and interactions are managed by our
 configuration management system Comar.
 PiSi merely passes those scripts to the Comar.
 Examples of them are given in the system configuration section of this
 article.
\end_layout

\begin_layout Subsection*
Package Manager
\end_layout

\begin_layout Standard
PiSi itself is written in Python too.
 This is a huge deviation from other well known package management software
 (Redhat's rpm or Debian's dpkg which are both written in C).
\end_layout

\begin_layout Standard
PiSi architecture is quite different from traditional designs.
 Every functionality, related to the package management like installing,
 building, fetching, dependency solving, repository management, validating
 is included in the core (compare with dpkg, apt-get or rpm, urpmi separation).
 PiSi can work with both binary repositories, and source packages like Gentoo's
 portage.
 On the other hand, package configuration (like calling ldconfig, modifying
 global configuration files, etc) is delegated to Comar.
\end_layout

\begin_layout Standard
PiSi source
\begin_inset LatexCommand cite
key "key-21"

\end_inset

 is 14245 lines of Python code distributed in 72 modules in 6 packages.
 Command line driver (pisi command) is just a simple frontend to all those
 modules.
 They can also be used together or partially by other programs.
 There are also a few more scripts, and a comprehensive test suite containing
 both unit tests, and full scenario tests.
\end_layout

\begin_layout Standard
An example test senario (scenarios/bug3481scen.py in PiSi source) is like
 this:
\end_layout

\begin_layout LyX-Code
from pisi.scenarioapi.scenario import *
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
HASHALOT="hashalot"
\end_layout

\begin_layout LyX-Code
COREUTILS="coreutils"
\end_layout

\begin_layout LyX-Code
GLIBC="glibc"
\end_layout

\begin_layout LyX-Code
UTIL_LINUX="util-linux"
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
let_repo_had(HASHALOT, with_partof("system.base"))
\end_layout

\begin_layout LyX-Code
let_repo_had(COREUTILS, with_partof("system.base"))
\end_layout

\begin_layout LyX-Code
let_repo_had(GLIBC, with_partof("system.base"))
\end_layout

\begin_layout LyX-Code
let_repo_had(UTIL_LINUX, with_partof("system.base"))
\end_layout

\begin_layout LyX-Code
let_pisi_had(COREUTILS, HASHALOT, GLIBC, UTIL_LINUX)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
def run():
\end_layout

\begin_layout LyX-Code
    repo_version_bumped(GLIBC)
\end_layout

\begin_layout LyX-Code
    repo_version_bumped(UTIL_LINUX)
\end_layout

\begin_layout LyX-Code
    repo_version_bumped(COREUTILS, with_added_conflicts(HASHALOT))
\end_layout

\begin_layout LyX-Code
    repo_updated_index()
\end_layout

\begin_layout LyX-Code
    pisi_upgraded() 
\end_layout

\begin_layout Standard
It is as readable as pseudo code, yet it works too.
\end_layout

\begin_layout Standard
A package management software deals a lot with sets, lists, and dependency
 graphs.
 Python has former two natively, and implementing latter is very simple
 with available primitives.
 Object oriented nature of Python, with module and package concepts, kept
 the code very modular and good structured.
 We have used functional operators (map, filter, reduce) and list comprehensions
 a lot.
 Even metaclasses are used in a few places.
\end_layout

\begin_layout Standard
An other reason to choose Python was its standart library.
 Although some parts of it (xml modules) are extremely slow and hard to
 use, and some parts (os, shutil, zipfile) needs a few wrappers to get it
 right, we have used quite a number of standart modules (like cPickle, re,
 unittest, subprocess, getopt, gettext, zlib, bz2, tarfile, urllib2, urlparse,
 sha).
 More information about our problems with the standart library can be found
 in problems section of this article.
 But all in all, they helped greatly by allowing us to reuse already tested
 components instead of writing everything from scratch.
\end_layout

\begin_layout Standard
We have only encountered a speed problem with XML parsing, which we solved
 by first migrating to 4suite parser, then our custom module.
 Currently there is a slowness only within certain database operations,
 but that is mostly caused by suboptimal use of BerkeleyDB, and will be
 fixed in the next major release.
 Most of the PiSi work is bounded by disc IO, and heavy calculation parts
 like dependency solving work really fast, if carefully coded by using as
 much as builtin functions of the Python.
\end_layout

\begin_layout Standard
A reason to code in C could be that you can statically compile everything
 into an executable, and run that even if every library in the system is
 broken.
 That is a trade-off, we decided to make.
 Currently PiSi depends on a minimal Python installation (with its library,
 and a few of modules), BerkeleyDB, piksemel (our XML python module) and
 glibc.
 Since those packages are required for operation, PiSi takes extra care
 while updating them.
\end_layout

\begin_layout Subsection*
User Interfaces
\end_layout

\begin_layout Standard
Main desktop environment of the Pardus is KDE.
 Python bindings
\begin_inset LatexCommand cite
key "key-22"

\end_inset

 of the KDE are highly maintained and very comprehensive.
 Every component of the desktop, be it an application, a control center
 module, an IO handler module, or a panel applet, can be written in Python.
 Similarly you can use almost any component like khtml from Python.
\end_layout

\begin_layout Standard
Graphical user interface of the PiSi is 2558 lines of Python code.
 This includes both a control center module, and a panel applet for regularly
 checking repositories and showing available updates.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
package-manager ekran görüntüsü
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another application using PiSi is Pardusman, a tool for making release media.
 You can select packages from a binary repository and easily make a live
 or install CD with a few clicks.
 It is 1481 lines of Python code.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
pardusman ekran görüntüsü
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you see, PiSi user interfaces are very short, yet quite capable programs.
 Coding in Python saves quite a bit of boiler plate code when compared to
 C++.
 Subclassing a window is just a 
\family typewriter
class MyWindow(QMainWindow)
\family default
 line for example.
\end_layout

\begin_layout Section
System Configuration
\end_layout

\begin_layout Standard
Configuring software and hardware is the most boring task, a user can do
 with a computer.
 Installing a program can require setting up some system variables.
 If you want to connect to the Internet, you have to set up some options
 of the network interface device, maybe even run some programs to handle
 the connection.
 Your hardware needs some kernel modules loaded, and some programs run to
 start operating.
 You may need to edit your xorg.conf file to be able to use native resolution
 of your LCD.
\end_layout

\begin_layout Standard
Hopefully most of these tasks can be automated, and other can be greatly
 simplified.
\end_layout

\begin_layout Standard
Our configuration framework Comar is designed to do that.
 Explaining all the details needs a separate article.
 We are going to layout only the general architecture here.
 So, basically,
\end_layout

\begin_layout Itemize
Configuration tasks are defined in a system model, grouped by classes which
 contain related tasks.
\end_layout

\begin_layout Itemize
Each software package can carry small configuration scripts for these classes.
\end_layout

\begin_layout Itemize
A class can be provided by different packages, also a package can provide
 different classes.
\end_layout

\begin_layout Itemize
When you call a configuration task, configuration script drives the package
 to do this job, by modifying its configuration file, sending signals, calling
 commands or using whatever mechanism is necessary.
\end_layout

\begin_layout Itemize
You can ask a task from a specific package, anyone who can do that job,
 or everyone providing that class.
\end_layout

\begin_layout Itemize
There is a daemon who keeps registered classes, listens for configuration
 calls, and runs the scripts.
\end_layout

\begin_layout Itemize
This daemon handles access control, so you can delegate some configuration
 permissions to normal users.
\end_layout

\begin_layout Standard
This architecture has quite a number of advantages.
 What we are interested here is that the actual logic of the configuration
 tasks are carried within package scripts.
 That way, packages are well encapsulated, different versions can have different
 ways of doing same tasks.
\end_layout

\begin_layout Standard
Theorically these scripts could be in any language.
 But there are many practical problems with that.
 Maintainance becomes harder with a big repository with scripts written
 in all sorts of languages.
 Function calling and parameter passing needs to be implemented for all
 those languages.
\end_layout

\begin_layout Standard
Since we already used Python in build scripts, also using it in configuration
 scripts came up as a natural choice.
 Several advantages are,
\end_layout

\begin_layout Itemize
Packagers need to know only one language,
\end_layout

\begin_layout Itemize
Comprehensive standart library with a wide range of extensions is available
 to use in scripts,
\end_layout

\begin_layout Itemize
Every feature of the Python is accessible and controllable from the Python
 C library,
\end_layout

\begin_layout Itemize
Scripts can be called by all users.
 They must have permission to make the call beforehand, but since script
 itself runs with a higher privilege, an interpreted language with garbage
 collection is very helpful against buffer overflow type attacks caused
 by malformed parameters from users.
\end_layout

\begin_layout Itemize
Comar daemon
\begin_inset LatexCommand cite
key "key-23"

\end_inset

 listens configuration requests and, if user has permission to do that,
 forks a job process for each call.
 This job process loads up package script and run it.
 That way configuration operations can run in parallel, and self contained.
\end_layout

\begin_layout Standard
We first tried to write this daemon in Python too, but changed to C later.
 Reason is that daemon is very small (6216 lines of C code) and very low
 level, there isn't much to gain from Python.
 Since Python interpreter is not even initialized in main process, resource
 usage is very low when there isn't a configuration job is running.
\end_layout

\begin_layout Standard
There are some common operations among the Comar scripts which are not covered
 by the standard library.
 These functions and a binding class for making Comar calls is included
 in a Python package.
 Here is an example using that Python binding:
\end_layout

\begin_layout LyX-Code
import comar
\end_layout

\begin_layout LyX-Code
link = comar.Link()
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
# Set some address parameters of a network connection
\end_layout

\begin_layout LyX-Code
link.Net.Link.setAddress(name="Home Network", address="192.168.3.165", gateway="192.168.
3.1")
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
# Query all system services
\end_layout

\begin_layout LyX-Code
link.System.Service.info()
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
# Read a result from the query
\end_layout

\begin_layout LyX-Code
reply = link.read_cmd()
\end_layout

\begin_layout LyX-Code
print reply.script, reply.data
\end_layout

\begin_layout Standard
These calls and their results are transferred to and from the Comar via
 a Unix socket internally.
\end_layout

\begin_layout Standard
In the current release of Pardus, package installation, system startup,
 display configuration, network and firewall configuration, user management,
 time and settings are all carried to the Comar.
 Scripts and graphical user interfaces are coded and running.
 More subsystems like power management and storage management are in progress.
 A few examples of current usage is given below.
\end_layout

\begin_layout Subsection*
Boot Subsystem
\end_layout

\begin_layout Standard
There is a separate article
\begin_inset LatexCommand cite
key "key-24"

\end_inset

 on our boot subsystem (called Mudur, means director in Turkish).
 We are going to give a summary of Python related features here.
\end_layout

\begin_layout Standard
System is made of a single Python script which handles basic initialization
 (starting udev, mounting filesystems, etc), and a System.Service Comar class
 with methods like start, stop, info, etc.
 Services are controlled by their Comar scripts.
 There are also a few tools (update-modules, update-environment, etc) rewritten
 in Python.
 Another Python agent deals with loading kernel modules and firmware for
 hardware, for both coldplugging and hotplugging.
\end_layout

\begin_layout Standard
In total of 2345 lines, Mudur makes Pardus, one of the fastest (in most
 configurations KDM login screen comes in 15-20 seconds) booting operating
 systems, with a highly maintainable, completely and easily localizable
 boot subsystem.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
servis yöneticisi ekran görüntüsü
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Network Subsystem
\end_layout

\begin_layout Standard
Basic class of the network system is Net.Link which defines a way (ethernet
 cable, wireless, ppp, vpn, etc) to connect a network.
 For an example, link.py script
\begin_inset LatexCommand cite
key "key-7"

\end_inset

 from wireless-tools package implements wireless connection with manual
 or automatic network configuration, WEP and WPA encryption, scanning, automatic
 detection of devices, and other basic functionality in 489 lines of Python
 code.
\end_layout

\begin_layout Standard
This is because most of the actual functionality is already implemented
 by tools like iwconfig, iwlist, dhcpcd, wpa_supplicant, etc.
 We just need to configure and use them according to user's wishes.
 This is very easy with Python, you can just import dbus, and for example
 talk to the WPA service with a few lines, unlike a C or shell based implementat
ion.
\end_layout

\begin_layout Standard
User interfaces can use this link providers in a highly generic way without
 caring about implementation details, since this is done over the Comar
 service, fine grained access permissions can be given to users.
\end_layout

\begin_layout Standard
There are other classes for firewall and name service configuration.
\end_layout

\begin_layout Standard
Graphical user interface itself is 2450 lines of Python code, including
 a panel applet.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
network manager scrshot
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Other Examples
\end_layout

\begin_layout Standard
Naturally package configuration is done with Comar too.
 Each package can provide a setup script with postInstall and preRemove
 methods.
 Additionally some packages would register their scripts on another class
 for operating on other packages' install and removal.
 That way, you can write scripts for operating on special kind of packages
 or files, like fonts, kernel modules, libraries, etc.
 Packages can inspect and register their plugins without providing each
 one with a script.
\end_layout

\begin_layout Standard
User management is another aspect handled by Comar.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
user manager scrshot
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We are developing an enterprise management system for controlling a network
 of computers.
 It is going to take global configuration policies from an LDAP server,
 and apply to the local system with Comar framework.
 Thus Comar will slowly cover all areas of the system configuration in the
 future.
\end_layout

\begin_layout Section
Applications and Scripts
\end_layout

\begin_layout Standard
Our installation program YALI
\begin_inset LatexCommand cite
key "key-8"

\end_inset

 is composed of 7521 line of Python code.
 Although it basically uses PiSi and Comar for installation, there are many
 hardware related modules, like a partition manager which contributes to
 the size.
 GUI code is also a bit big, beacuse installation environment only has Qt
 widgets running on a bare X Window server.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
yalı scrshot
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is a KControl replacement we wrote, which uses both KDE control center
 modules, and our control center modules written in Python.
\end_layout

\begin_layout Standard
Our buildfarm software
\begin_inset LatexCommand cite
key "key-9"

\end_inset

 is 878 lines of Python.
 Checks out package descriptions from subversion repository, finds new releases,
 builds them, builds the other packages requiring recompile, sends packaged
 binaries to the file server.
 We are looking for a web based interface for the build farm, probably based
 on Django.
\end_layout

\begin_layout Standard
There several small scripts, validating the integrity of package repositories,
 generating web pages for packages, and countless smaller scripts for doing
 one time jobs written.
\end_layout

\begin_layout Section
Custom Modules
\end_layout

\begin_layout Standard
In the process of Pardus development, we have encountered some common problems,
 and wrote some generic modules to deal with them.
\end_layout

\begin_layout Subsection*
piksemel
\end_layout

\begin_layout Standard
Unfortunately XML module of the standard Python library is too slow for
 serious usage.
 Parsing the package content information of the TeTeX PiSi package (a 2.137.893
 bytes XML file), for example, takes almost two seconds on a 1.66 GHz dual
 core Intel processor.
 Another problem is the API is cumbersome to use, and quite un-Pythonic.
\end_layout

\begin_layout Standard
We first switched to 4suite package, and gained quite a bit of speed.
 Then wrote our own module based on iksemel [sayfasina link ver] library.
 It is very small (designed mainly for embedded systems), and much faster
 than other parsers.
 Python API we add around it is designed to be easy to use and more Pythonic.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
örnekler
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
catbox
\end_layout

\begin_layout Section
Problems
\end_layout

\begin_layout Standard
https://sourceforge.net/tracker/?func=detail&aid=1507247&group_id=5470&atid=30547
0
\end_layout

\begin_layout Standard
https://sourceforge.net/tracker/index.php?func=detail&aid=1513206&group_id=5470&at
id=305470
\end_layout

\begin_layout Standard
https://sourceforge.net/tracker/index.php?func=detail&aid=1509889&group_id=5470&at
id=305470
\end_layout

\begin_layout Standard
https://sourceforge.net/tracker/?func=detail&atid=105470&aid=1336623&group_id=547
0
\end_layout

\begin_layout Standard
http://tinyurl.com/y4bwf5
\end_layout

\begin_layout Standard
http://tinyurl.com/twkns
\end_layout

\begin_layout Standard
https://sourceforge.net/tracker/index.php?func=detail&aid=1056231&group_id=5470&at
id=305470
\end_layout

\begin_layout Standard
https://sourceforge.net/tracker/index.php?func=detail&aid=1454485&group_id=5470&at
id=305470
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
evaluation of python:
\end_layout

\begin_layout Standard
-rapid development
\end_layout

\begin_layout Standard
-speed
\end_layout

\begin_layout Standard
-i18n
\end_layout

\begin_layout Standard
-learning curve (for developers, and outside packagers)
\end_layout

\begin_layout Standard
-standart library
\end_layout

\begin_layout Standard
-bugs
\end_layout

\begin_layout Standard
final word
\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
key "key-6"

\end_inset

Quotes about Python, 
\begin_inset LatexCommand url
name "http://www.python.org/Quotes.html"
target "http://www.python.org/Quotes.html"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
key "key-5"

\end_inset

Pisi article, 
\begin_inset LatexCommand url
name "http://www.pardus.org.tr/eng/projects/pisi/PiSi.html"
target "http://www.pardus.org.tr/eng/projects/pisi/PiSi.html"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
key "key-19"

\end_inset

Official package repository, 
\begin_inset LatexCommand url
name "http://svn.pardus.org.tr/pardus/devel/"
target "http://svn.pardus.org.tr/pardus/devel/"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
key "key-20"

\end_inset

Contrib package repository, 
\begin_inset LatexCommand url
name "http://svn.pardus.org.tr/contrib/"
target "http://svn.pardus.org.tr/contrib/"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
key "key-21"

\end_inset

Pisi source, 
\begin_inset LatexCommand url
name "http://svn.pardus.org.tr/uludag/trunk/pisi/"
target "http://svn.pardus.org.tr/uludag/trunk/pisi/"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
key "key-22"

\end_inset

PyQt and PyKDE, 
\begin_inset LatexCommand url
name "http://www.riverbankcomputing.co.uk/pyqt/"
target "http://www.riverbankcomputing.co.uk/pyqt/"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
key "key-23"

\end_inset

Comar system service, 
\begin_inset LatexCommand url
name "http://svn.pardus.org.tr/uludag/trunk/comar/comar/"
target "http://svn.pardus.org.tr/uludag/trunk/comar/comar/"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
key "key-24"

\end_inset

Mudur article, 
\begin_inset LatexCommand url
name "http://www.pardus.org.tr/eng/projeler/comar/SpeedingUpLinuxWithPardus.html"
target "http://www.pardus.org.tr/eng/projeler/comar/SpeedingUpLinuxWithPardus.html"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
key "key-7"

\end_inset

Wireless script, 
\begin_inset LatexCommand url
name "http://svn.pardus.org.tr/pardus/2007/system/base/wireless-tools/comar/link.py"
target "http://svn.pardus.org.tr/pardus/2007/system/base/wireless-tools/comar/link.py"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
key "key-8"

\end_inset

Pardus installer, 
\begin_inset LatexCommand url
name "http://svn.pardus.org.tr/uludag/trunk/yali/"
target "http://svn.pardus.org.tr/uludag/trunk/yali/"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
key "key-9"

\end_inset

Pardus build farm software, 
\begin_inset LatexCommand url
name "http://svn.pardus.org.tr/uludag/trunk/buildfarm/"
target "http://svn.pardus.org.tr/uludag/trunk/buildfarm/"

\end_inset


\end_layout

\end_body
\end_document

#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2006-2010 TUBITAK/UEKAE
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Please read the COPYING file.

import os
os.environ["LC_ALL"] = "C"

import sys
import glob
import copy
import shutil
import cPickle
import traceback
import cStringIO

from buildfarm import logger, mailer, queuemanager, pisiinterface, utils, twit
from buildfarm.config import configuration as conf

def build_packages():
    # FIXME: Refactor
    def remove_binary_package_from_workdir(package):
        try:
            os.remove(os.path.join(conf.workdir, package))
        except:
            # Don't fail if we can't remove the files
            pass

    qmgr = queuemanager.QueueManager()

    qmgr.transferAllPackagesToWorkQueue() #move all packages to workQueue for compilation
    queue = copy.copy(qmgr.workQueue)

    # We'll set home variable just after build process to make revdep work right
    homeDir = os.environ['HOME']

    packageList = []
    deltaPackageList = []
    isopackages = {}

    # Create Twitter instance
    my_twitter = twit.Twitter()

    if len(queue) == 0:
        logger.info("Work Queue is empty...")
        sys.exit(1)

    # FIXME: Use fcntl.flock
    f = open("/var/run/buildfarm", 'w')
    f.close()

    # Unpickle and load ISO package list here if conf.generatedelta is true.
    if conf.generatedelta:
        try:
            isopackages = cPickle.Unpickler(open("data/packages.db", "rb")).load()
        except:
            logger.error("You have to create packages.db in data/ for delta generation.")
            os.unlink("/var/run/buildfarm")
            sys.exit(1)

    # Compiling current workQueue

    logger.raw("QUEUE")
    logger.info("*** All packages to be compiled : %s" % qmgr.workQueue)

    mailer.info("I'm starting to compile packages in the following order:\n\n%s" % "\n".join(queue))
    logger.raw()

    for pspec in queue:
        packagename = utils.get_package_name_from_path(pspec)
        build_output = open(os.path.join(conf.outputdir, "%s.txt" % packagename), "w")
        logger.raw()
        log_msg = "Compiling %s (%d/%d)" % (packagename, int(queue.index(pspec)+1), len(queue))
        logger.info("*** %s" % log_msg)

        # Twit if possible
        my_twitter.update(log_msg)

        # This is here because farm captures the build output
        pisi = pisiinterface.PisiApi(stdout = build_output, stderr = build_output, outputDir = conf.workdir)
        try:
            try:
                # Save current *.pisi file list in /var/pisi for further cleanup
                pisiList = glob.glob1(conf.workdir, "*.pisi")

                # Build source package
                # Returned values can also contain -dbginfo- packages.
                (newBinaryPackages, oldBinaryPackages) = pisi.build(pspec)

                # Reduce to filenames
                newBinaryPackages = map(lambda x: os.path.basename(x), newBinaryPackages)
                oldBinaryPackages = map(lambda x: os.path.basename(x), oldBinaryPackages)

                # Filter debug packages because we don't need to build delta packages
                # for debug packages
                newDebugPackages = [p for p in newBinaryPackages if utils.is_debug_package(p)]
                oldDebugPackages = [p for p in oldBinaryPackages if utils.is_debug_package(p)]

                newBinaryPackages = list(set(newBinaryPackages).difference(newDebugPackages))
                oldBinaryPackages = list(set(oldBinaryPackages).difference(oldDebugPackages))

                newBinaryPackages.sort()
                oldBinaryPackages.sort()

                # Delta package generation using delta interface
                # If the return value is None, delta generation is disabled
                ret = pisi.delta(isopackages, oldBinaryPackages, newBinaryPackages)
                if ret:
                    (deltasToInstall, deltaPackages, blacklistedPackages) = ret
                else:
                    (deltasToInstall, deltaPackages, blacklistedPackages) = ([], [], [])

                # Reduce to filenames
                deltasToInstall = map(lambda x: os.path.basename(x), deltasToInstall)
                deltaPackages = map(lambda x: os.path.basename(x), deltaPackages)

                # If there exists incremental delta packages, install them.
                if deltasToInstall:
                    packagesToInstall = deltasToInstall[:]
                    if len(newBinaryPackages) > len(oldBinaryPackages):
                        logger.info("*** There are new binaries, the package is probably splitted.")

                        # There exists some first builds, install them because they don't have delta.
                        packagesToInstall.extend(newBinaryPackages[len(oldBinaryPackages):])
                        logger.debug("(splitted package), packagesToInstall: %s" % packagesToInstall)
                else:
                    # No delta, install full packages
                    packagesToInstall = newBinaryPackages[:]

                if blacklistedPackages:
                    # Merge the blacklisted packages and unify the list
                    logger.debug("blacklistedPackages: %s" % blacklistedPackages)
                    packagesToInstall.extend(blacklistedPackages)
                    packagesToInstall = list(set(packagesToInstall))
                    logger.debug("packagesToInstall after merge: %s" % packagesToInstall)

                # Merge the package lists
                deltaPackages = deltaPackages + deltasToInstall
                logger.debug("All delta packages: %s" % deltaPackages)

            except Exception, e:
                # Transfer source package to wait queue in case of a build error
                qmgr.transferToWaitQueue(pspec)

                # If somehow some binary packages could have been build, they'll stay in /var/pisi
                # We should remove them here.
                for p in set(glob.glob1(conf.workdir, "*.pisi")).difference(pisiList):
                    logger.info("*** Removing stale package '%s' from '%s'" % (p, conf.workdir))
                    remove_binary_package_from_workdir(p)

                errmsg = "Error occured for '%s' in BUILD process:\n %s" % (pspec, e)
                logger.error(errmsg)
                mailer.error(errmsg, pspec)
            else:
                try:
                    # If there exists multiple packages, reorder them in order to
                    # correctly install interdependent packages.
                    if len(packagesToInstall) > 1:
                        # packagesToInstall doesn't contain full paths
                        logger.info("*** Reordering packages to satisfy inner runtime dependencies...")
                        packagesToInstall = pisi.get_install_order(packagesToInstall)
                        logger.info("*** Installation order is: %s" % packagesToInstall)

                    for p in packagesToInstall:
                        # Install package
                        logger.info("*** Installing: %s" % os.path.join(conf.workdir, p))
                        pisi.install(os.path.join(conf.workdir, p))
                except Exception, e:
                    # Transfer source package to wait queue in case of an install error
                    qmgr.transferToWaitQueue(pspec)

                    # FIXME: The packages before packagesToInstall[p] are already installed and therefore need to be
                    # uninstalled because p can't be installed.
                    if utils.isdelta(p) and "no attribute 'old_files'" in str(e):
                        logger.info("*** %s was probably not installed on the system and the delta installation failed." % utils.get_package_name(p))
                    errmsg = "Error occured for '%s' in INSTALL process: %s" % (os.path.join(conf.workdir, p), e)
                    logger.error(errmsg)
                    mailer.error(errmsg, pspec)

                    # The package should be removed from the related lists and WorkDir in case of an
                    # installation problem
                    for pa in deltaPackages+newBinaryPackages+newDebugPackages:
                        if pa in deltasToInstall:
                            deltasToInstall.remove(pa)
                        elif pa in newBinaryPackages:
                            newBinaryPackages.remove(pa)
                        logger.info("*** (Cleanup) Removing %s from %s" % (pa, conf.workdir))
                        remove_binary_package_from_workdir(pa)
                else:
                    qmgr.removeFromWorkQueue(pspec)
                    move_packages(newBinaryPackages, oldBinaryPackages, deltaPackages, newDebugPackages)
                    packageList += (map(lambda x: os.path.basename(x), newBinaryPackages))
                    deltaPackageList += (map(lambda x: os.path.basename(x), deltaPackages))

        finally:
            pisi.close()
            os.environ['HOME'] = homeDir

    logger.raw("QUEUE")
    logger.info("*** Wait Queue: %s" % (qmgr.waitQueue))
    if qmgr.waitQueue:
        mailer.info("Queue finished with problems and those packages couldn't be compiled:\n\n%s\n\n\nNew binary packages are;\n\n%s\n\nnow in repository" % ("\n".join(qmgr.waitQueue), "\n".join(packageList)))
    else:
        mailer.info("Queue finished without a problem!...\n\n\nNew binary packages are:\n\n%s\n\n"
                    "New delta packages are:\n\n%s\n\nnow in repository..." % ("\n".join(packageList), "\n".join(deltaPackageList)))
    logger.raw()
    logger.raw()

    # Save current path
    current = os.getcwd()

    # Set index paths
    paths = [conf.binarypath, conf.testpath]
    if conf.debugsupport:
        # Enable debugSupport in config to generate an index
        # for the debug repository.
        paths.append(conf.debugpath)

    for d in paths:
        os.chdir(d)
        logger.info("\n*** Generating repository index in %s:" % d)
        os.system("/usr/bin/pisi index %s . --skip-signing --skip-sources" % utils.get_local_repository_url())
        logger.info("*** Repository index generated for %s" % d)

    # Go back to the saved directory
    os.chdir(current)

    # Check packages containing binaries and libraries broken by any package update
    print "\n*** Checking binary consistency with revdep-rebuild.."
    os.system("/usr/bin/revdep-rebuild --force")

    # FIXME: Use fcntl.funlock
    os.unlink("/var/run/buildfarm")

def move_packages(newBinaryPackages, oldBinaryPackages, deltaPackages, debugPackages):

    def cleanup_stale_delta_packages(package):
        # Say that 'package' is kernel-2.6.25.20-114.45.pisi
        # We can remove delta packages going to any build < 45 from both
        # packages/ and packages-test/ because we no longer need them.
        for p in utils.get_deltas_not_going_to(conf.binarypath, package):
            logger.info("*** Removing stale delta '%s' from '%s'" % (p, conf.binarypath))
            os.remove(os.path.join(conf.binarypath, p))

        for p in utils.get_deltas_not_going_to(conf.testpath, package):
            logger.info("*** Removing stale delta '%s' from '%s'" % (p, conf.testpath))
            os.remove(os.path.join(conf.testpath, p))

    def remove_old_package(package):
        logger.info("*** Removing old package '%s' from '%s'" % (package, conf.testpath))
        if os.path.exists(os.path.join(conf.testpath, package)):
            # If an old build is found in testpath remove it because the test repo is unique.
            os.remove(os.path.join(conf.testpath, package))

        # Cleanup workdir
        if os.path.exists(os.path.join(conf.workdir, package)):
            os.remove(os.path.join(conf.workdir, package))

    def move_new_package(package):
        logger.info("*** Moving new package '%s'" % package)
        if os.path.exists(os.path.join(conf.workdir, package)):
            shutil.copy(os.path.join(conf.workdir, package), conf.binarypath)
            shutil.copy(os.path.join(conf.workdir, package), conf.testpath)
            os.remove(os.path.join(conf.workdir, package))

    def move_unchanged_package(package):
        logger.info("*** Moving unchanged package %s'" % package)
        if os.path.exists(os.path.join(conf.workdir, package)):
            shutil.copy(os.path.join(conf.workdir, package), conf.binarypath)
            os.remove(os.path.join(conf.workdir, package))

    def move_delta_package(package):
        # Move all delta packages into packages/ and packages-test/
        # and clean them from workdir.
        logger.info("*** Moving delta package '%s' to both directories" % package)
        if os.path.exists(os.path.join(conf.workdir, package)):
            shutil.copy(os.path.join(conf.workdir, package), conf.binarypath)
            shutil.copy(os.path.join(conf.workdir, package), conf.testpath)
            os.remove(os.path.join(conf.workdir, package))

    def move_debug_package(package):
        # Move all debug packages into packages-debug/ and clean them
        # from WorkDir.
        logger.info("*** Moving debug package '%s' to packages-debug" % package)
        if os.path.exists(os.path.join(conf.workdir, package)):
            shutil.copy(os.path.join(conf.workdir, package), conf.debugpath)
            os.remove(os.path.join(conf.workdir, package))

    # Normalize files to full paths
    try:
        newBinaryPackages = set(map(lambda x: os.path.basename(x), newBinaryPackages))
    except AttributeError:
        pass

    try:
        oldBinaryPackages = set(map(lambda x: os.path.basename(x), oldBinaryPackages))
    except AttributeError:
        pass

    unchangedPackages = set(newBinaryPackages).intersection(set(oldBinaryPackages))
    newPackages = set(newBinaryPackages) - set(oldBinaryPackages)
    oldPackages = set(oldBinaryPackages) - set(unchangedPackages)

    logger.info("*** New binary package(s): %s" % newPackages)
    logger.info("*** Old binary package(s): %s" % oldPackages)
    logger.info("*** Unchanged binary package(s): %s" % unchangedPackages)
    logger.info("*** Delta package(s): %s" % deltaPackages)
    logger.info("*** Debug package(s): %s" % debugPackages)

    for package in newPackages:
        if package:
            # Move the new binary package to packages/ and packages-test/
            move_new_package(package)

    for package in oldPackages:
        if package:
            # Remove old binary package from packages-test/
            remove_old_package(package)

    for package in unchangedPackages:
        if package:
            move_unchanged_package(package)

    for package in deltaPackages:
        # Move all(3) delta packages to packages/ and packages-test/
        if package:
            move_delta_package(package)

    if deltaPackages:
        for package in newPackages:
            # Remove delta packages going to any build != newPackage's build
            if package:
                cleanup_stale_delta_packages(package)

    if debugPackages:
        for package in debugPackages:
            # Move debug packages to packages-debug/
            if package:
                move_debug_package(package)



### Entry point ###

def handle_exception(exception, value, tb):
    s = cStringIO.StringIO()
    traceback.print_tb(tb, file = s)
    s.seek(0)

    logger.error(str(exception))
    logger.error(str(value))
    logger.error(s.read())


if __name__ == "__main__":
    sys.excepthook = handle_exception

    # Just to make sure
    utils.create_directories()

    build_packages()

#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2006-2010 TUBITAK/UEKAE
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Please read the COPYING file.

import os
os.environ["LC_ALL"] = "C"

import sys
import copy
import shutil
import traceback
import cStringIO

import pisi.context as ctx

from buildfarm import logger, mailer, queuemanager, pisiinterface, utils, twit
from buildfarm.config import configuration as conf

def build_packages():
    qmgr = queuemanager.QueueManager()

    qmgr.transfer_all_packages_to_work_queue() #move all packages to workQueue for compilation
    queue = copy.copy(qmgr.get_work_queue())

    if len(queue) == 0:
        logger.info("Work Queue is empty...")
        sys.exit(1)

    # We'll set home variable just after build process to make revdep work right
    home_dir = os.environ["HOME"]

    package_list = []

    # Create Twitter instance
    my_twitter = twit.Twitter()

    # Compiling current work queue

    logger.raw("QUEUE")
    logger.info(" All packages to be compiled : %s" % qmgr.get_work_queue())

    mailer.info("I'm starting to compile packages in the following order:\n\n%s" % "\n".join(queue))
    logger.raw()

    for pspec in queue:
        package_name = utils.get_package_name_from_path(pspec)
        package_name_with_component = utils.get_package_component_path(pspec)
        build_output = open(os.path.join(utils.get_package_log_directory(), "%s.txt" % package_name), "w")
        logger.raw()

        log_msg = "Building %s (%d/%d)" % (package_name, int(queue.index(pspec)+1), len(queue))
        logger.info(log_msg)

        # Twit if possible
        my_twitter.update(log_msg)

        # This is here because farm captures the build output
        pisi = pisiinterface.PisiApi(stdout = build_output,
                                     stderr = build_output,
                                     outputDir = conf.workdir)
        try:
            try:
                # Build source package
                pisi.build(pspec)

                # These lists contain full path to the .pisi files
                new_binary_packages = pisi.get_new_packages()
                new_debug_packages = pisi.get_new_debug_packages()

                # Reorder packages before installation
                packages_to_install = pisi.get_install_order(new_binary_packages)

            except Exception, e:
                # Transfer source package to wait queue in case of a build error
                qmgr.transferToWaitQueue(pspec)

                # Cleanup possibly built .pisi packages
                utils.delete_pisi_files_from(conf.workdir)

                errmsg = "Error occured while building %s:\n %s" % (package_name_with_component, e)
                logger.error(errmsg)
                mailer.error(errmsg, pspec)

            else:
                # Build was successful, let's install the packages
                try:
                    for pkg in packages_to_install:
                        # Install package
                        logger.info("Installing: %s" % pkg)
                        pisi.install(pkg)
                except Exception, e:
                    # Transfer source package to wait queue in case of an install error
                    qmgr.transferToWaitQueue(pspec)

                    # Cleanup possibly built .pisi packages
                    utils.delete_pisi_files_from(conf.workdir)

                    errmsg = "Error occured while installing %s:\n %s" % (os.path.basename(pkg), e)
                    logger.error(errmsg)
                    mailer.error(errmsg, pspec)
                else:
                    # Installation was successful
                    qmgr.removeFromWorkQueue(pspec)
                    move_packages(new_binary_packages, new_debug_packages)
                    package_list += [os.path.basename(pkg) for pkg in new_binary_packages]

        finally:
            pisi.close()
            os.environ["HOME"] = home_dir

    logger.info("Wait Queue: %s" % (qmgr.get_wait_queue()))
    if qmgr.get_wait_queue():
        mailer.info("Queue finished with problems and those packages couldn't be compiled:\n\n%s\n\n\nNew binary packages are;\n\n%s\n\nnow in repository" % ("\n".join(qmgr.get_wait_queue()), "\n".join(package_list)))
    else:
        mailer.info("Queue finished without a problem.\n\n\nNew binary packages are:\n\n%s\n\n" % ("\n".join(package_list)))
    logger.raw()
    logger.raw()

    # Save current path
    current = os.getcwd()

    # Set index paths
    paths = [utils.get_compiled_packages_directory()]
    if ctx.config.values.build.generatedebug:
        paths.append(utils.get_debug_packages_directory())

    for directory in paths:
        os.chdir(directory)
        logger.info("\n Generating repository index in %s:" % directory)
        os.system("/usr/bin/pisi index %s . --skip-signing --skip-sources" % utils.get_local_repository_url())
        logger.info(" Repository index generated for %s" % directory)

    # Go back to the saved directory
    os.chdir(current)

    # Check packages containing binaries and libraries broken by any package update
    print "\n Checking binary consistency with revdep-rebuild.."
    os.system("/usr/bin/revdep-rebuild --force")

def move_packages(new_binary_packages, new_debug_packages):

    def move_package(package, target):
        logger.info("Moving %s into %s" % (package, target))
        try:
            shutil.move(os.path.join(conf.workdir, package), target)
        except shutil.Error:
            pass

    logger.info("New binary package(s): %s" % new_binary_packages)
    logger.info("New debug package(s): %s" % new_debug_packages)

    for package in new_binary_packages:
        move_package(package, utils.get_compiled_packages_directory())

    for package in new_debug_packages:
        move_package(package, utils.get_debug_packages_directory())


### Entry point ###

def handle_exception(exception, value, trace_back):
    string_io = cStringIO.StringIO()
    traceback.print_tb(trace_back, file = string_io)
    string_io.seek(0)

    logger.error(str(exception))
    logger.error(str(value))
    logger.error(string_io.read())

if __name__ == "__main__":
    sys.excepthook = handle_exception

    # Just to make sure
    utils.create_directories()

    build_packages()

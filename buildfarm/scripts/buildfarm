#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2006-2010 TUBITAK/UEKAE
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Please read the COPYING file.

import os
os.environ["LC_ALL"] = "C"

import sys
import glob
import copy
import shutil
import traceback
import cStringIO

import pisi.context as ctx

from buildfarm import logger, mailer, queuemanager, pisiinterface, utils, twit
from buildfarm.config import configuration as conf

def build_packages():
    # FIXME: Refactor
    def remove_binary_package_from_workdir(package):
        try:
            os.remove(os.path.join(conf.workdir, package))
        except:
            # Don't fail if we can't remove the files
            pass

    qmgr = queuemanager.QueueManager()

    qmgr.transfer_all_packages_to_work_queue() #move all packages to workQueue for compilation
    queue = copy.copy(qmgr.get_work_queue())

    if len(queue) == 0:
        logger.info("Work Queue is empty...")
        sys.exit(1)

    # We'll set home variable just after build process to make revdep work right
    home_dir = os.environ['HOME']

    packageList = []

    # Create Twitter instance
    my_twitter = twit.Twitter()

    # Compiling current workQueue

    logger.raw("QUEUE")
    logger.info(" All packages to be compiled : %s" % qmgr.get_work_queue())

    mailer.info("I'm starting to compile packages in the following order:\n\n%s" % "\n".join(queue))
    logger.raw()

    for pspec in queue:
        package_name = utils.get_package_name_from_path(pspec)
        package_name_with_component = utils.get_package_component_path(pspec)
        build_output = open(os.path.join(utils.get_package_log_directory(), "%s.txt" % package_name), "w")
        logger.raw()

        log_msg = "Building %s (%d/%d)" % (package_name, int(queue.index(pspec)+1), len(queue))
        logger.info(log_msg)

        # Twit if possible
        my_twitter.update(log_msg)

        # This is here because farm captures the build output
        pisi = pisiinterface.PisiApi(stdout = build_output, stderr = build_output, outputDir = conf.workdir)
        try:
            try:
                # Save current *.pisi file list in /var/pisi for further cleanup
                pisiList = glob.glob1(conf.workdir, "*.pisi")

                # Build source package
                pisi.build(pspec)

                # FIXME:
                newBinaryPackages = pisi.get_new_packages()

                # Reduce to filenames
                newBinaryPackages = map(lambda x: os.path.basename(x), newBinaryPackages)

                # Filter debug packages because we don't need to build delta packages
                # for debug packages
                newDebugPackages = pisi.get_new_debug_packages()

                # No delta, install full packages
                # NOTE: This was in the else block above
                packagesToInstall = newBinaryPackages[:]

            except Exception, e:
                # Transfer source package to wait queue in case of a build error
                qmgr.transferToWaitQueue(pspec)

                # If somehow some binary packages are built, they'll stay in /var/pisi
                # We should remove them here.
                for p in set(glob.glob1(conf.workdir, "*.pisi")).difference(pisiList):
                    logger.info(" Removing stale package '%s' from '%s'" % (p, conf.workdir))
                    remove_binary_package_from_workdir(p)

                errmsg = "Error occured while building %s:\n %s" % (package_name_with_component, e)
                logger.error(errmsg)
                mailer.error(errmsg, pspec)
            else:
                try:
                    # FIXME: Can't this be passed to pisi?
                    # If there exists multiple packages, reorder them in order to
                    # correctly install interdependent packages.
                    if len(packagesToInstall) > 1:
                        # packagesToInstall doesn't contain full paths
                        logger.info("Reordering packages to satisfy inner runtime dependencies.")
                        packagesToInstall = pisi.get_install_order(packagesToInstall)
                        logger.info("Installation order is: %s" % packagesToInstall)

                    for p in packagesToInstall:
                        # Install package
                        logger.info("Installing: %s" % os.path.join(conf.workdir, p))
                        pisi.install(os.path.join(conf.workdir, p))
                except Exception, e:
                    # Transfer source package to wait queue in case of an install error
                    qmgr.transferToWaitQueue(pspec)

                    errmsg = "Error occured while installing %s:\n %s" % (p, e)
                    logger.error(errmsg)
                    mailer.error(errmsg, pspec)

                    # The package should be removed from the related lists and WorkDir in case of an
                    # installation problem
                    for pa in newBinaryPackages+newDebugPackages:
                        if pa in newBinaryPackages:
                            newBinaryPackages.remove(pa)
                        logger.info("Removing %s from %s" % (pa, conf.workdir))
                        remove_binary_package_from_workdir(pa)
                else:
                    qmgr.removeFromWorkQueue(pspec)
                    move_packages(newBinaryPackages, newDebugPackages)
                    packageList += (map(lambda x: os.path.basename(x), newBinaryPackages))

        finally:
            pisi.close()
            os.environ['HOME'] = home_dir

    logger.raw("QUEUE")
    logger.info("Wait Queue: %s" % (qmgr.get_wait_queue()))
    if qmgr.get_wait_queue():
        mailer.info("Queue finished with problems and those packages couldn't be compiled:\n\n%s\n\n\nNew binary packages are;\n\n%s\n\nnow in repository" % ("\n".join(qmgr.get_wait_queue()), "\n".join(packageList)))
    else:
        mailer.info("Queue finished without a problem.\n\n\nNew binary packages are:\n\n%s\n\n" % ("\n".join(packageList)))
    logger.raw()
    logger.raw()

    # Save current path
    current = os.getcwd()

    # Set index paths
    paths = [utils.get_compiled_packages_directory()]
    if ctx.config.values.build.generatedebug:
        paths.append(utils.get_debug_packages_directory())

    for directory in paths:
        os.chdir(directory)
        logger.info("\n Generating repository index in %s:" % directory)
        os.system("/usr/bin/pisi index %s . --skip-signing --skip-sources" % utils.get_local_repository_url())
        logger.info(" Repository index generated for %s" % directory)

    # Go back to the saved directory
    os.chdir(current)

    # Check packages containing binaries and libraries broken by any package update
    print "\n Checking binary consistency with revdep-rebuild.."
    os.system("/usr/bin/revdep-rebuild --force")

def move_packages(newBinaryPackages, debugPackages):

    def move_new_package(package):
        logger.info("Moving new package '%s'" % package)
        packages_dir = utils.get_compiled_packages_directory()
        if os.path.exists(os.path.join(conf.workdir, package)):
            shutil.copy(os.path.join(conf.workdir, package), packages_dir)
            os.remove(os.path.join(conf.workdir, package))

    def move_debug_package(package):
        # Move all debug packages into packages-debug/ and clean them
        # from WorkDir.
        debug_dir = utils.get_debug_packages_directory()
        logger.info("Moving debug package '%s' to '%s'" % (package, debug_dir))
        if os.path.exists(os.path.join(conf.workdir, package)):
            shutil.copy(os.path.join(conf.workdir, package), debug_dir)
            os.remove(os.path.join(conf.workdir, package))

    # Normalize files to full paths
    try:
        newBinaryPackages = set(map(lambda x: os.path.basename(x), newBinaryPackages))
    except AttributeError:
        pass

    newPackages = set(newBinaryPackages)

    logger.info("New binary package(s): %s" % newPackages)
    logger.info("Debug package(s): %s" % debugPackages)

    for package in newPackages:
        if package:
            # Move the new binary package to packages/ and packages-test/
            move_new_package(package)

    if debugPackages:
        for package in debugPackages:
            # Move debug packages to packages-debug/
            if package:
                move_debug_package(package)



### Entry point ###

def handle_exception(exception, value, tb):
    s = cStringIO.StringIO()
    traceback.print_tb(tb, file = s)
    s.seek(0)

    logger.error(str(exception))
    logger.error(str(value))
    logger.error(s.read())


if __name__ == "__main__":
    sys.excepthook = handle_exception

    # Just to make sure
    utils.create_directories()

    build_packages()

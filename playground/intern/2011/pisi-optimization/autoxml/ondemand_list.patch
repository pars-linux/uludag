diff -Nuar pisi_orig209/pxml/autoxml.py pisi/pxml/autoxml.py
--- pisi_orig209/pxml/autoxml.py	2011-08-20 11:13:25.876000004 +0300
+++ pisi/pxml/autoxml.py	2011-08-20 16:16:12.972000053 +0300
@@ -40,6 +40,8 @@
 import pisi.util as util
 import pisi.oo as oo
 
+import ondemand
+
 class Error(pisi.Error):
     pass
 
@@ -336,11 +338,11 @@
         cls.__init__ = initialize
 
         cls.decoders = decoders
-        def decode(self, node, errs, where = unicode(cls.tag)):
+        def decode(self, node, errs, where = unicode(cls.tag), use_ondemand = False):
             for base in cls.autoxml_bases:
-                base.decode(self, node, errs, where)
+                base.decode(self, node, errs, where, use_ondemand)
             for decode_member in decoders:#self.__class__.decoders:
-                decode_member(self, node, errs, where)
+                decode_member(self, node, errs, where, use_ondemand)
             if hasattr(self, 'decode_hook'):
                 self.decode_hook(node, errs, where)
         cls.decode = decode
@@ -418,11 +420,12 @@
             cls.__ne__ = notequal
 
         if xmlfile_support:
-            def parse(self, xml, keepDoc = False):
+            def parse(self, xml, keepDoc = False, use_ondemand = False):
                 "parse XML string and decode it into a python object"
+                self.use_ondemand = use_ondemand
                 self.parsexml(xml)
                 errs = []
-                self.decode(self.rootNode(), errs)
+                self.decode(self.rootNode(), errs, use_ondemand=self.use_ondemand)
                 if errs:
                     errs.append(_("autoxml.parse: String '%s' has errors") % xml)
                     raise Error(*errs)
@@ -437,16 +440,18 @@
                     errs.append(_("autoxml.parse: String '%s' has errors") % xml)
 
             def read(self, uri, keepDoc = False, tmpDir = '/tmp',
-                     sha1sum = False, compress = None, sign = None, copylocal = False, nodecode = False):
+                     sha1sum = False, compress = None, sign = None, copylocal = False, nodecode = False,
+                     use_ondemand = False):
                 "read XML file and decode it into a python object"
+                self.use_ondemand = use_ondemand
+
                 read_xml = self.readxml(uri, tmpDir, sha1sum=sha1sum, 
                              compress=compress, sign=sign, copylocal=copylocal)
-
                 if nodecode:
                     return read_xml
 
                 errs = []
-                self.decode(self.rootNode(), errs)
+                self.decode(self.rootNode(), errs, use_ondemand=self.use_ondemand)
                 if errs:
                     errs.append(_("autoxml.read: File '%s' has errors") % uri)
                     raise Error(*errs)
@@ -552,9 +557,9 @@
             """initialize component"""
             setattr(self, name, init_a())
 
-        def decode(self, node, errs, where):
+        def decode(self, node, errs, where, use_ondemand):
             """decode component from DOM node"""
-            setattr(self, name, decode_a(node, errs, where + '.' + unicode(name)))
+            setattr(self, name, decode_a(node, errs, where + '.' + unicode(name), use_ondemand))
 
         def encode(self, node, errs):
             """encode self inside, possibly new, DOM node using xml"""
@@ -642,7 +647,7 @@
             """default value for all basic types is None"""
             return None
 
-        def decode(node, errs, where):
+        def decode(node, errs, where, use_ondemand):
             """decode from DOM node, the value, watching the spec"""
             text = readtext(node, token)
             #print 'read text ', text
@@ -693,12 +698,12 @@
         def init():
             return make_object()
 
-        def decode(node, errs, where):
+        def decode(node, errs, where, use_ondemand):
             node = xmlext.getNode(node, tag)
             if node:
                 try:
                     obj = make_object()
-                    obj.decode(node, errs, where)
+                    obj.decode(node, errs, where, use_ondemand)
                     return obj
                 except Error:
                     errs.append(where + ': '+ _('Type mismatch: DOM cannot be decoded'))
@@ -755,8 +760,16 @@
         def init():
             return []
 
-        def decode(node, errs, where):
-            l = []
+        def decode(node, errs, where, use_ondemand):
+            # print use_ondemand
+            # if use_ondemand == False:
+            #     from traceback import print_stack
+            #     print_stack()
+
+            if use_ondemand:
+                l = ondemand.OnDemandList()
+            else:
+                l = []
             nodes = xmlext.getAllNodes(node, path)
             #print node, tag + '/' + comp_tag, nodes
             if len(nodes)==0 and req==mandatory:
@@ -765,7 +778,10 @@
             for node in nodes:
                 dummy = xmlext.newNode(node, "Dummy")
                 xmlext.addNode(dummy, '', node)
-                l.append(decode_item(dummy, errs, where + unicode("[%s]" % ix)))
+                if use_ondemand:
+                    l.append(ondemand.OnDemandListItem(decode_item, dummy, errs, where + unicode("[%s]" % ix)))
+                else:
+                    l.append(decode_item(dummy, errs, where + unicode("[%s]" % ix), use_ondemand))
                 #l.append(decode_item(node, errs, where + unicode("[%s]" % ix)))
                 ix += 1
             return l
@@ -786,9 +802,14 @@
         def errors(l, where):
             errs = []
             ix = 1
-            for node in l:
-                errs.extend(errors_item(node, where + '[%s]' % ix))
-                ix += 1
+            if isinstance(l, ondemand.OnDemandList):
+                # FIXME : ???
+                pass
+            else:
+                for node in l:
+                    errs.extend(errors_item(node, where + '[%s]' % ix))
+                    ix += 1
+
             return errs
 
         def format(l, f, errs):
@@ -815,7 +836,7 @@
         def init():
             return make_object()
 
-        def decode(node, errs, where):
+        def decode(node, errs, where, use_ondemand):
             if node:
                 try:
                     obj = make_object()
diff -Nuar pisi_orig209/pxml/ondemand.py pisi/pxml/ondemand.py
--- pisi_orig209/pxml/ondemand.py	1970-01-01 02:00:00.000000000 +0200
+++ pisi/pxml/ondemand.py	2011-08-20 16:14:40.727000066 +0300
@@ -0,0 +1,201 @@
+# -*- coding: utf-8 -*-
+
+class OnDemandListItem(object):
+
+    def __init__(self, decode_function, node, errs, where):
+        self.decode_function = decode_function
+        self.node = node
+        self.errs = errs
+        self.where = where
+
+    def decode(self):
+        # print "decoding", self.where
+        return self.decode_function(self.node, self.errs, self.where, True)
+
+class OnDemandList(list):
+
+    def __init__(self):
+        super(OnDemandList, self).__init__()
+        self.functions = []
+        self.undecoded_count = 0
+
+    def __getitem__(self, y):
+        item = super(OnDemandList, self).__getitem__(y)
+
+        if isinstance(item, OnDemandListItem):
+            item = item.decode()
+            super(OnDemandList, self).__setitem__(y, item)
+            self.undecoded_count -= 1
+
+        return item
+
+    def decodeall_run_f(self, y, f):
+        print "decodeall: ", f
+        self.decodeAll()
+        if isinstance(y, OnDemandList):
+            y.decodeAll()
+
+        return super(OnDemandList, self).__getattribute__(f)(y)
+
+    def append(self, y):
+        if isinstance(y, OnDemandListItem):
+            self.undecoded_count += 1
+
+        return super(OnDemandList, self).append(y)
+
+    def count(self, y):
+        self.decodeAll()
+        return super(OnDemandList, self).count(y)
+
+    def extend(self, i):
+        return decodeall_run_f(i, 'extend')
+
+    def index(self, value, start = None, stop = None):
+        # FIXME : ???
+        print "index", value, start, stop
+        self.decodeAll()
+        return super(OnDemandList, self).index(value, start, stop)
+
+    # def insert(self, index, o):
+
+    def pop(self, index = None):
+        a = super(OnDemandList, self).pop(index)
+        if isinstance(a, OnDemandListItem):
+            a = a.decode()
+        return a
+
+    def remove(self, value):
+        self.decodeAll()
+        return super(OnDemandList, self).remove(value)
+
+    def sort(cmp = None, key=None, reverse=False):
+        self.decodeAll()
+        return super(OnDemandList, self).sort(cmp, key, reverse)
+
+    def __add__(self, y):
+        self.decodeall_run_f(y, '__add__')
+
+    def __contains__(self, y):
+        if self.undecoded_count > 0:
+            self.decodeAll()
+        return super(OnDemandList, self).__contains__(y)
+
+    def __delitem__(self, y):
+        if not self.isDecoded(y):
+            self.undecoded_count -= 1
+        return super(OnDemandList, self).__delitem__(y)
+
+    def __delslice__(self, i, j):
+        # TODO: test yap, bu fonksiyon __delitem__ i kullanÄ±yor olabilir.
+        for x in range(i, j):
+            if not self.isDecoded(x):
+                self.undecoded_count -= 1
+
+        return super(OnDemandList, self).__delslice__(i, j)
+
+    def __eq__(self, y):
+        if isinstance(y, list):
+            return self.decodeall_run_f(y, '__eq__')
+
+        return False
+
+    def __ge__(self, y):
+        return self.decodeall_run_f(y, '__ge__')
+
+    def __getslice__(self, i, j):
+        # TODO: test yap, ...
+        # Decode slice
+        for x in range(i, j):
+            self.__getitem__(x)
+        return super(OnDemandList, self).__getslice__(i, j)
+
+    def __gt__(self, y):
+        return self.decodeall_run_f(y, '__gt__')
+
+    def __iadd__(self, y):
+        return self.decodeall_run_f(y, '__iadd__')
+
+    def __imul__(self, y):
+        return self.decodeall_run_f(y, '__imul__')
+
+    def __iter__(self):
+        for i in xrange(len(self)):
+            yield self.__getitem__(i)
+
+    def __le__(self, y):
+        return self.decodeall_run_f(y, '__le__')
+
+    def __lt__(self, y):
+        return self.decodeall_run_f(y, '__lt__')
+
+    def __mul__(self, y):
+        return self.decodeall_run_f(y, '__mul__')
+
+    def __ne__(self, y):
+        if isinstance(y, list):
+            return self.decodeall_run_f(y, '__ne__')
+
+        return True
+
+    def __reduce__(self):
+        # print "reduce"
+        self.decodeAll()
+        return super(OnDemandList, self).__reduce__()
+
+    def __reduce_ex__(self, protocol):
+        # print "reduce_ex"
+        self.decodeAll()
+        return super(OnDemandList, self).__reduce_ex__(protocol)
+
+    # __repr__(self)
+
+    def __reversed__(self):
+        for i in xrange(len(self)-1, -1, -1):
+            yield self.__getitem__(i)
+
+    def __rmul__(self, y):
+        return self.decodeall_run_f(y, '__rmul')
+
+    def __setitem__(self, i, y):
+        if not self.isDecoded(i):
+            self.undecoded_count -= 1
+
+        if isinstance(y, OnDemandListItem):
+            self.undecoded_count += 1
+
+        return super(OnDemandList, self).__setitem__(i, y)
+
+    def isDecoded(self, y):
+        if len(self.functions) > y and self.functions[y]:
+            return False
+        else:
+            return True
+
+    def safeIter(self):
+        class iterator(object):
+            def __init__(self, obj):
+                self.obj = obj
+                self.index = -1
+
+            def __iter__(self):
+                return self
+
+            def next(self):
+                self.index+=1
+                if self.index >= len(self.obj):
+                    raise StopIteration
+                # print len(self.obj), self.index #
+
+                while not self.obj.isDecoded(self.index):
+                    self.index += 1
+                    if self.index >= len(self.obj):
+                        raise StopIteration
+
+                return self.obj[self.index]
+
+        return iterator(self)
+
+    def decodeAll(self):
+        if self.undecoded_count > 0:
+            for x in xrange(len(self)):
+                self.__getitem__(x)

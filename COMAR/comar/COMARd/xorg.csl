# startup script for autoconfiguring xorg
# doesnt use COMAR:Desktop at the moment, scans hw directly

method ConfigureDisplay(dpi=80) {

	#modes = capture(exec="/usr/sbin/ddcxinfo-knoppix -monitor");
	#xini_change_section(cfgfile="/home/palpa/xorg.conf",section="Monitor",content=modes);
	#xini_change_option(cfgfile="/home/palpa/xorg.conf",section="Device",option="Driver",value="nvidia");
	# First search LCD Panel..

	xout = capture(exec="/usr/X11R6/bin/X -configure -logfile /var/log/xlog");
	xout = xini_parse(cfgfile="/root/xorg.conf.new");
	psize = "";
	debugout(value=xout);

	if (xout["S Device"]["V Driver"] != "") {

		xdrv = xout["S Device"]["V Driver"];
		xdrv = strip(string = xdrv);
		debugout(value=xdrv);
		if (xdrv == '"nv"') {
			#Panel size is %i x %i
			psize = grepfirst(exec="/bin/cat /var/log/xlog", pattern="Panel size is");
		}
		elif (xdrv == '"nvidia"') {
			#Panel size is %i x %i
			psize = grepfirst(exec="/bin/cat /var/log/xlog", pattern="Panel size is");

		} elif (xdrv == '"ati"') {
			#Panel Size from BIOS: %dx%d\n
			xout = capture(exec="/usr/X11R6/bin/X -probeonly -logfile /var/log/xlog");
			psize = grepfirst(exec="/bin/cat /var/log/xlog", pattern="Panel Size from");
			drv_flags["DDCMode"] = "on";

		} elif (xdrv == '"via"') {
			#Detected panel size via BIOS: %d x %d
			psize = grepfirst(exec="/bin/cat /var/log/xlog", pattern="Detected panel size via");
		}
	}

	#psize = "1400 x 1050";
	#debugout(value=psize);

	if (psize != "") {
		debugout(value=psize);
		px = split(string=psize, separator="x");
		debugout(value=px);
		resx = getnumright(string = strip(string = px[0]));
		resy = getnumleft(string = strip(string = px[1]));
		# Calculate Modeline..
		v1 = 0;
		v2 = 0;
		step = 10.0;
		s_rr = 60.0;
		dcf = 1.0;
		hfl = 4.0;
		vfl = 5000.0;
		hfrontmin = 0.50;
		hsyncmin = 1.20;
		hbackmin = 1.25;
		hblankmin = 4.00;
		hsfmax = 60.0;
		vfrontmin = 0.0;
		vsyncmin = 45.0;
		vbackmin = 500.0;
		vblankmin = 600.0;
		vsfmax  = 90.0;
		cont = 1;

		while (cont == 1) {

			py = hfl * vfl;
			rr = (dcf / py) * 1000000.0;
			hsf = (dcf / hfl) * 1000.0;

			hfront = hfrontmin * dcf + resx;
			if ( int(string=hfront) % 8 ) { hfront = 8 * (1 + int(string=hfront/8)); }

			hsync = hsyncmin * dcf + hfront;
			if ( int(string=hsync) % 8) { hsync = 8 * (1 + int(string=hsync/8)); }

			hblank = hblankmin * dcf;
			hfl = resx + hblank;
			if ( int(string=hfl) % 8 ) { hfl = 8 * (1 + int(string=hfl/8)); }

			vtick = hfl / dcf;
			vfront = resy + vfrontmin / vtick;

			vsync = vfront + vsyncmin / vtick;
			vback = vbackmin / vtick;
			vblank = vblankmin / vtick;

			vfl = vsync + vback;

			t = (resy + vblank);

			if ( vfl <  t ) {
				vfl = resy + vblank;
			}

			v1 = int(string = rr * 1000.0);
			v2 = int(string = s_rr * 1000.0);
			debugout(value="V1 V2 STEP = "+v1+" "+v2+" "+step);
			if ( v1 == v2 ) {
				cont = 0;

			} elif ( v1 < v2 ) {
				dcf = dcf + step;

			} elif ( v1 > v2 ) {
				dv = v1 - v2;
				dcf = dcf - step;
				step = step / 10.0;
			}

		}
		modeline = "ModeLine " + int(string=resx) + " " + int(string=resy);
		modeline =  modeline + " " + dcf + " " + int(string=resx) + " ";
		modeline =  modeline + int(string=hfront) + " " + int(string=hsync) + " " + int(string=hfl) + " " + int(string=resy) + " " + int(string=vfront) + " " + int(string=vsync) + " " + int(string=vfl);
	} else {

		s = grepfirst(exec="/usr/sbin/ddcxinfos", pattern="truly");
		if ( s == "") {
			s = grepfirst(exec="/usr/sbin/ddcxinfos", pattern="truly");
		}
		if ( s == "") {
			s = grepfirst(exec="/usr/sbin/ddcxinfos", pattern="truly");
		}
		if (s != "") {
			w = split(string=s, separator=" ");
			inc = getnumleft(string = w[4]);
			pix = 4 * (inc / 5) * dpi;
		}
	}

	DisplayInfo = xdrv + " " + "resx="+resx+" resy="+resy+" pix="+pix+" inc="+inc;
	if (psize == "") {
		vals[1600] = "1600 1200";
		vals[1280] = "1280 1024";
		vals[1152] = "1152 864";
		vals[1024] = "1024 768";
		vals[800]  = "800 600";
		DisplayInfo = getnearvalue(look = pix, values = vals);
	}

	# Detect mouse...

	xout = capture(exec="/bin/cat /proc/bus/input/devices");

	coll = 1;

	BTN_LEFT  = 16;
	BTN_RIGHT = 17;
	BTN_MID   = 18;
	BTN_SIDE  = 19;
	BTN_EXTRA = 20;

	REL_WHEEL = 8;
	absn = 0;

	foreach (key = val in xout) {
		val = strip(string = val);
		debugout(value="VAL:'"+val+"'");
		if (substr_left(string = val, size = 6) == "B: EV=") {
			ev = split(string = val, separator = "=");
			ev = split(string = ev[1], separator = " ");
			ev = hex2dec(value=ev[0]);

		} elif (substr_left(string = val, size = 7) == "B: KEY=") {
			btn = split(string = val, separator = "=");
			btn = split(string = btn[1], separator = " ");
			btn = hex2dec(value=btn[0]);

		} elif (substr_left(string = val, size = 7) == "B: REL=") {
			rel = split(string = val, separator = "=");
			rel = split(string = rel[1], separator = " ");
			rel = hex2dec(value=rel[0]);
		} elif (substr_left(string = val, size = 7) == "B: ABS=") {
			absn = split(string = val, separator = "=");
			absn = split(string = absn[1], separator = " ");
			absn = hex2dec(value=absn[0]);

		}

		if (val == "") {
			# All data collected..
			subtype = "";
			if ( absn != 0) {
				# We found a touchpad !!
				mtype = "PS/2";
				subtype = "touch";
				wheel = 0;
				break;

			} else {
				btn_count = 0;

				if (getbit(value=btn, bit=BTN_LEFT)) {
					btn_count = 1 + btn_count;
				}

				if (getbit(value=btn, bit=BTN_RIGHT)) {
					btn_count = 1 + btn_count;
				}

				debugout(value=btn_count);

				if (btn_count != 0) {
					# We found a mouse !!
					mtype = "PS/2";
					wheel = getbit(value=rel, bit=REL_WHEEL);
					if (getbit(value=btn, bit=BTN_MID)) btn_count = btn_count + 1;
					if (getbit(value=btn, bit=BTN_SIDE))
						btn_count = btn_count + 1;
					if (getbit(value=btn, bit=BTN_EXTRA)) {
						if (getbit(value=rel, bit=REL_WHEEL)) {
							mtype = "ExplorerPS/2";
						}
					} else {
						if (getbit(value=rel, bit=REL_WHEEL)) {
							mtype = "IMPS/2";
						}
					}
					break;
				}
			}
		}
	}
	ConfigureDisplay = DisplayInfo + " Mtype: " + mtype + " BTNCount: " + btn_count + " ModeLine: " + modeline;
}

COMAR Uygulama Gereksinimleri

COMARd uygulamasý için gereksinim duyulan nesneler ve bu nesnelerin saðlamasý istenen görevler þöyle sýralanabilir:

1.	objHook		: Nesneleri iþletmeden sorumlu asýl bileþendir. Temel olarak Container ile nesne kodu (CSL, Python, rpc etc.) arasýnda baðlantý görevini yerine getirir.
	*	Container ile veri alýþveriþini IPC üzerinden saðlayabilmelidir. Bunun yanýnda standart stack based çaðrýlarda kullanýlabilir olmalýdýr.
	*	Thread-safe olmalýdýr.
	*	Bilgi alýþveriþi için COMARRPCData ve COMARValue veri tiplerini kullanmalýdýr.
	*	Sleep/weak-up desteði olmalýdýr.
		Sleep için bir girdi kabul etmeli, bu girdi alýnýnca en uygun zamanda kendini askýya alabilmelidir.
	*	StateSave/StateRestore desteði olmalýdýr.
		Yürüttüðü kodun/iþlemin o anki durumunu kaydedebilmelidir.
	*	resume desteði olmalýdýr.
		Herhangi bir anda yarým kalmýþ iþlemine kadlýðý yerden devam etmek üzere resume edilebilmelidir.
	*	objhook'tan istenen düðüm bilgisi bir defa set edilmeli, tekrar eden çaðrýlarda objhook ait olduðu düðüme ait yordamlarý otomatik yükleyebilmelidir.
	*	Persistent data tracking ve COMAR LOW LEVEL API için COMARAPI bileþenlerini kullanmalýdýr.
	*	Sistem çaðrýlarý için Container tarafýndan saðlanan CAPI bileþenlerini kullanmalýdýr.
	*	Gerekli olan data ile ilgili bilgilere callerInfoObject veri tipi üzerinden eriþmelidir.
	*	Container ve COMARAPI gibi çaðrýlarýnda tümünde callerInfoObject veri tipi sunulmalýdýr.
2.	NSContainer	: COMARd'nin geri kalan kýsmý ile objHook arasýnda bir glue görevi görür. Ayrýca düðüme atanmýþ birden fazla objHook olmasý durumunda bunlarýn container'a baðlanmasý görevlerini de yürütmelidir.
	*	Thread-safe olmasý gereklidir.
	*	objHook ve kendini yürüten bileþenlere callerInfoObject veritipi ile parametre geçirmelidir.
	*	Her bir objhook'u paralel çalýþtýrabilmeli, gerekiyorsa bu objhook'larýn herbirinin ürettiði verileri biraraya toplayabilmeldir. Eðer geriye dönen veri bir nesne ise, bu durumda her bir nesne için prototip bilgisini nesne private data üzerinde tutabilmelidir.
	*	Ait olduðu düðüme ait olan objhook nesnelerini doðrudan oluþturmadan COMARMODSTACK üzerinden kullanmalý, bu nesnelerin sadece bir instance'ýný elde tutmalýdýr.
	*	Diðer tüm birimlerle veri alýþveriþini COMARValue üzerinden saðlamalýdýr.
3.	CAPI		: CAPI, COMAR uygulamalarý için gerekli olan düþük düzey fonksiyoneliteyi saðlar. CAPI, bir API Driver ve bununla sistem baðlanan birden fazla sayýda API sunucu modülden oluþur. Her bir modül aþaðýdaki bilgileri içermelidir:

	APICLASS	= Bu modülün adý.
	APICALLS	= API için gereken vtbl. Bu tablo çaðrýlabilir fonksiyon adlarý için fonksiyon giriþlerini gösterir.

	Bir modül içinde tanýmlanan fonksiyonlar tamamen þu prototip üzerinden çaðrýlabilir:
		fonksiyon adý, parametre_listesi, checkPerms fonksiyon giriþi, callerInfoObject olarak çaðýran uygulamanýn callerInfo verisi.

	Modüller thread safe olmalýdýr. Her zaman COMARRetVal ile iþlev sonuçlarýný geri döndürmelidirler. Kullanýlan parametrelerde her zaman COMARValue formatýnda olmalýdýr.
4.	COMARAPI	: COMAR temel iþlevlerini üstlenir. Bu iþlevler, COMARValue gibi veri yapýlarýnýn desteklenmesi, persistent veriler için çaðrýlar ve benzerleridir.
	*	Nesne instance'larýný oluþturma/saklama/geri alma.
	*	Nesne veritabaný iþlevleri.
	*	RPC Client Mode çaðrýlarý.
	*	Logging iþlevleri
	*	Event registration Low Level bileþenleri
	*	COMAR Kullanýcý veritabaný iþlevleri.
5.	COMARValue	API	: COMARValue, COMARRetVal gibi temel veri türlerini oluþturma/modifiye etme iþlevlerini üstlenir.
	*	String, Numeric, Array ve Object veri tipleri için platform baðýmsýz, C ile kolay modifiye edilebilen, memory gibi referanslar kullanmayan bir genel veri kapsülleme yöntemi sunmak.
	*	Her tür COMARValue için XML (vb.) veri kapsülleme & serialization fonksiyonlarý saðlamak.
6.	OBJDRIVER	: COMARd içinde alýnan çaðrýlara uygun olarak nesnelerin ilgili fonksiyonlarýnýn çaðrýlmasý için uygun Container'i oluþturmak ve iþletmekle sorumludur.
	*	ACL denetimlerini yapabilmelidir.
	*	PRERUN/POSTRUN iþlemlerini yerine getirebilmelidir.
	*	Blocked ve Non-blocked olarak çalýþabilmeli, thread-safe olmalýdýr.
	*	RESUME/RUN ve CALL gibi yöntemleri desteklemelidir.
7.	COMAR-CORE	:
	COMARd'nin çekirdek görevlerini üstlenir.
	*	Event kaynaklarýný takip etmek.
	*	Timer iþlevlerini takip etmek.
	*	OBJDRIVER'lar için gereken scheduling iþlevlerini sunmak.
	*	task kuyruklarý yoluyla gerektiði durumlarda çalýþan yordamlarý uyutabilmek vs.
	*	COMAR-RPC iþlevlerini yönetmek.
8.	COMAR-RPC	:
	COMAR için gerekli olabilecek RPC iþlemlerini saðlar.
	*	RPC çaðrýlarý almak, iþletmek, sonuçlarý geriye döndürmek.
	*	DATAGRAM (e-mail, sms etc.) için gerekli handshaking vs. görevlerini saðlamak.
	*	Alýnan istekler için authentication ve authorization iþlevini gerçekleþtirmek.
	*	Ýþlenecek olan istekleri COMAR-CORE'a devretmek.
	COMAR-RPC birer  I/O low-level access modülü ve bu modüller için bir iþletici olan ana kodu ihtiva eder.
	Modüller iki gruba ayrýlýr. Server mode ve Client Mode.
	Server mode modüller þu fonksiyoneliteye sahip olmalýdýr:
	*	Ayrý bir process olarak çalýþabilmelidir.
	*	LISTEN/ACCEPT ardýndan ana COMAR Core'a elde edilen veriyi COMARRPCData formatýnda iletmek üzere IPC üzerinden saðlamak.
	*	SHMEM ile COMAR-CORE'dan elde edilen COMARRPCData verisini RESPONSE olarak karþýya yollamak.
	*	AUTH verilerini COMARAPI üzerinden saðlamalýdýr.
	Client Mode modüller:
	*	Ayrý bir process/thread olarak çalýþabilmelidir.
	*	CONNECT ile yollanacak bilgiyi IPC üzerinden alýp kullanabilmelidir.
	*	RESPONSE baðlantýlarýný IPC üzerinden iþletebilmelidir.
	*	COMAR-CORE baðlantýlarý tamamen COMARRPCData formatýnda yapýlmalýdýr.
	*	Remote için gereken auth bilgisini kendi saklayabilmelidir.
	Tüm modüller ise:
	*	RPCTYPE		- RPC türü (HTTP-XML/HTTPS-XML, MSG-XML vs.)
	*	LOGLEVEL	- Hangi seviyede loglama yapýlacaðý. 0 - None, 1 - WARNINGS, 2 - CALLS, 3 - DEBUG MODE

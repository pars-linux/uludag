CSL Fonksiyonlarý

CSL, temel olarak iki farklý fonksiyon seti sunar. CSL API, deðiþkenleri ve deðerleri iþlemek için gerekli olan temel fonksiyonlarý içerir. CSL CAPI ise, dosya eriþimi, program çalýþtýrma gibi sistem kaynaklarýna eriþim gerektiren fonksiyonlarý sunar. CSL CAPI fonksiyonlarý, eriþim kontrolüne tabidir.

CSL API:

1.	Numeric fonksiyonlar:

getbit
	Prototype:
		bit_value = numeric_var.getbit(bit = position);
		bit_value = getbit(value = look_value, bit = position);
	Description:
		"value" için "bit" pozisyonundaki bitin deðerini döndürür. Position, LSB'de 0 ile baþlayýp MSB'ye doðru artar.
	Sample:
		x = getbit(value = 255, bit = 0); # Look bit 0 in 11111111b, return 1
		x = getbit(value = 176, bit = 0); # Look bit 0 in 10101010b, return 0
		x = getbit(value = 176, bit = 1); # Look bit 0 in 10101010b, return 1

getnearvalue
	Prototype:
		near_value = array_value.getnearvalue(look = numeric);
		near_value = getnearvalue(array = array_value, look = numeric);
	Description:
		array_value, key deðerleri bakýlacak sayýlarla, her keyin karþýlýðý ise geri döndürülecek sayýlarla dolu olan bir array olmalýdýr. Fonksiyon bu array'ýn keylerine bakarak, istenen look deðerine en yakýn olan elemanýn deðerini döndürür.
	Sample:
		arr[100] = "A";
		arr[150] = "B";
		arr[175] = "C";
		arr[190] = "D";

		val = arr.getnearvalue(value = 130); # val = "B"
		val = arr.getnearvalue(value = 120); # val = "A"
		val = getnearvalue(array = arr, value = 180); # val = "C"

int
	Prototype:
		val = numeric_var.int();
		val = int(value = numeric_var);
	Description:
		numeric_var'ýn tamsayý deðerini döndürür. Yuvarlama her zaman alta doðru yapýlýr.
	Sample:
		x = 5.75;
		y = x.int(); # y = 5
		y = int(value = 10.1); # y = 10

array ve string fonksiyonlarý

arraygrep
	Prototype:
		values = array_value.arraygrep(pattern = pattern_string);
		values = arraygrep(array = array_value, pattern = pattern_string);
	Description:
		array_value'nun deðerlerinden, pattern_string'i ihtiva edenlerin keylerini yeni bir array olarak döndürür.
	Sample:
		arr[0] = "foo bar";
		arr[1] = "no bar";
		arr[2] = "foo";
		arr[3] = "bar";

		keys = arr.arraygrep(pattern = "oo"); # keys["000000"] = 0, keys["000001"] = 2
		keys = arraygrep(array = arr, pattern = " "); # keys["000000"] = 0, keys["000001"] = 1
	Notes:
		CSL içinde, "000000" ile 0, "000001" ile 1 array indexi olarak birbirine eþittir. Yukarýdaki örnek için, keys[0] ile keys["000000"] ayný elemanlardýr.

replacetokens
	Prototype:
		result_buffer = source_buffer.replacetokens([tokenid = token_char], fields = fields_array);
		result_buffer = replacetokens(buffer = source_buffer, [tokenid = token_char], fields = fields_array);
	Description:
		source_buffer içersindeki fields_array'ýn keyleri ile tarif edilmiþ olan fields'leri, fields_array'ýn eleman deðeri ile deðiþtirip, sonucu geri döndürür.
		fields_array, her eleman için, key = bakýlacak pattern, value = yeni deðer þeklinde bir arraydýr. Burada pattern deðerinde ASCII olarak A-Z arasý büyük/küçük harfler, 0-9 arasý sayýlar ve "_" iþareti kullanýlabilir.Bu kýsýtlama operasyon için yeterli olmasýna raðmen, eðer diðer karakterler kullanýlmak istenirse source_buffer içersindeki saha tanýmlamalarýnýn ${..} formatýnda yapýlmasý gerekir. Bu durumda, bilhassa UTF-8 -> ISO8859* çevrimleri gibi sorunlarýn doðabileceði gözden kaçýrýlmamalýdýr.
		tokenid, patternlerin baþladýðýný belirten özel karakterdir. Varsayýlan deðeri "$" þeklindedir. source_buffer içersinde, bu tokenid karakteri ardý ardýna iki kere yazýlýrsa, bu noktada pattern aramasý yapýlmaz, bir tek tokenid bu pozisyona yerleþtirilir.

		Bir token, source_buffer içinde <tokenid>field veya <tokenid>{field} þeklinde bulunmalýdýr.
	Sample:
		field["height"] = 640;
		field["width"]  = 800;
		buffer1 = "Area = $height x $width";
		buffer2 = "$$Area=${height}x${width}";
		result = buffer1.replacetokens(fields = field, tokenid = "$"); # result -> "Area = 640 x 800"
		result = replacetokens(buffer = buffer2, fields = field, tokenid = "$"); # result -> "$Area=640x800"

strupper/strlower
	Prototype:
		new_string = string_value.strupper();
		new_string = string_value.strlower();
		new_string = strupper(string = string_value);
		new_string = strlower(string = string_value);
	Description:
		strupper, string_value'yu tüm harfleri büyük harfe, strlower ise küçük harfe çevirip döndürür. Çevrim, yerel dile baðýmlý olarak yapýlýr.
	Sample:
		str = "ali";
		up  = str.strupper(); # up -> "ALÝ"
		low = strlower(string = up); # low = "ali"

strip
	Prototype:
		new_string = string_value.strip();
		new_string = strip(string = string_value);
	Description:
		string_value'nun baþýnda ve sonunda bulunan beyaz boþluklarý kaldýrýr.
	Sample:
		str = "\t \tali\n\t";
		str = str.strip(); # str = "ali"

startswith
	Prototype:
		bool_numeric = string_value.startswith(prefix = prefix_string);
		bool_numeric = startswith(string = string_value, prefix = prefix_string);
	Description:
		Eðer string_value, prefix_string ile baþlýyorsa, geriye 1, aksi durumda, 0 döndürür.
	Sample:
		str = "foo bar foobar";
		b = str.startswith(prefix = "fo"); # b = 1
		b = startswith(string = str, prefix = "bar"); # b = 0

split/splitws
	Prototype:
		new_string = string_value.split(separator = sep_string);
		new_string = string_value.splitws();
		new_string = split(string = string_value, separator = sep_string);
		new_string = splitws(string = string_value);
	Description:
		split, string_value'yu her biri sep_string ile ayrýlan bölümlere ayýrýp, bu bölümleri bir array olarak geri döndürür. splitws, separator olarak "\t", "\n" ve " " karakterlerini kullanýr. Diðer bazý dillerde, ardarda gelen separatorler için, boþ deðerler üretilirken, CSL için bu deðerler ihmal edilir.
	Sample:
		str = "foo bar\tfoobar\t\t  barfoo";
		arr = str.split(separator = " ");
		# arr[000000] = "foo", arr[000001] = "bar\tfoobar\t\t", arr[000002] = "barfoo"
		arr = str.splitws();
		# arr[000000] = "foo", arr[000001] = "bar", arr[000002] = "foobar", arr[000003] = "barfoo"

strlen
	Prototype:
		num = string_value.strlen();
		num = strlen(string = string_value);
	Description:
		string_value'nun karakter cinsinden uzunluðunu verir. UTF-8 gibi bir karakterin birden fazla bayt kapladýðý durumlarda, bu tür karakterler tek karakter olarak yorumlanýr. String'in buffer olarak boyunu öðrenmek üzere, bytelen() fonksiyonu kullanýlabilir.
	Sample:
		str = "123";
		len = str.strlen(); # len -> 3

strstr/strcasestr
	Prototype:
		bool = string_value.strstr(pattern = pattern_string);
		bool = string_value.strcasestr(pattern = pattern_string);
		bool = strstr(string = string_value, pattern = pattern_string);
		bool = strcasestr(string = string_value, pattern = pattern_string);
	Description:
		Eðer, string_value içersinde pattern_string varsa, geriye 1 döndürürken aksi durumda 0 döndürür. strcasestr için iþlem büyük/küçük harf ayrýmý yapýlmaksýzýn gerçekleþir.
	Sample:
		str = "foo bar foobar barfoo";
		x = str.strstr(pattern="foobar"); # x = 1
		x = str.strstr(pattern="FOOBAR"); # x = 0
		x = str.strcasestr(pattern="FOOBAR"); # x = 1
		x = str.strstr(pattern="other"); # x = 0




COMAR 1.0 Specification..

What is COMAR ?

	COMAR, Nesneye yönelik bir yürütme (execution) ortamýdýr. Bu ortam yoluyla remote/local veya dil ayrýmý olmaksýzýn nesneler çaðýrýlýp iþletilebilir. COMAR, bir yan ürün olarak CSL - COMAR Scripting Language sunar. Yürütülen uygulamalarýn CSL dilinde olmasý zorunluluðu yoktur.

	COMAR, özellikle yapýlandýrma görevleri için dizayn edilmiþtir. Bu sebeple performans gibi tipik uygulamalarda gözetilen bazý unsurlar ikinci plana alýnmýþtýr.

COMAR Nesne Modeli:

	Bir COMAR nesnesini kavramak, COMAR Nesne Modelini anlamakla mümkündür. Bu ise öncelikle yapýlandýrma gereksinimlerini iyi kavramakla mümkündür.

	Bizim bakýþýmýzla yapýlandýrma süreci iki ayrý sürece bölünebilir. Birinci süreç, uygulamanýn çalýþtýðý ortama adaptasyonudur. Burada kritik olan ve genelde gözardý edilen husus, çalýþma ortamýnýn da uygulamaya uydurulmasý gerekliliðidir. Ýkinci süreç ise uygulamanýn diðer uygulamalar ile baðlantýsý olmayan, diðer uygulama ve bileþenleri etkilemeyen yapýlandýrma seçenekleri yoluyla özelleþtirilmesidir.

	Adaptasyon süreci göründüðünden çok daha karmaþýk bir durum sunmaktadýr. Güncel ortamda herhangi bir uygulamayý diðer uygulamalardan baðýmsýz düþünmek imkansýzdýr. Bu iyi bilinen bir durumdur ve bazý hilelerle bir nebze aþýlabilir. Çok baþvurulan bir yöntem, sisteme dahil edilen uygulamalarý kýsýtlý tutmaktýr. Seçilen uygulamalarýn baðýmlý olduklarý farzedilen uygulamalar birbirlerine göre önceden uyarlanmýþ hale getirilirler. Sistem bir görev için belli bir uygulamayý koþulsuz kabul eder. Sistemin varsayýlanlarý dýþýna çýkmadýðýnýz sürece genellikle sorun yoktur.

	Fakat, bu varsayýlanlarýn çýð gibi büyüyen bilgisayar sektörünün gereksinimlerini karþýlamasý pek mümkün olmaz. Kullanýcýlar kendi gereksinimlerine göre ortama yeni bileþenler eklemek isterler. Ayrýca sistemin kurulmasýnýn hemen ertesinden baþlayarak teknoloji, kullanýcý istekleri vb. hýzla geliþmeye baþlar. Dahasý, farzedilen gereksinimlerin kullanýcýnýn gereksinimlerine ne kadar örtüþtüðü önceden öngörülemez. Sonuçta öngörülemeyen istekleri karþýlamak imkansýz hale gelir. Çeþitli ufak düzeltmeler bir süre sonra sistemi varsayýlanlardan uzaklaþtýrýr. Buna baðlý olarak uygulamalar arasýndaki uyumluluk ve yapýlandýrma aracýnýn bu uyumluluðu koruma kabiliyeti azalýr. Bu da baþta bakým problemleri olmak üzere çeþitli ek sorunlar çýkarýr. Pek çok kullanýcý kritik yapýlandýrma görevleri için mevcut yapýlandýrma araçlarý yerine elle konfigürasyonlarý yönetmeye baþlar. Bu sonun baþlangýcýdýr. Kullanýcý hýzla HOWTO'lara boðulmaya baþlar. Teknik altyapýsý yeterli olmayanlar için bu süreç tam bir kabus halini alabilir.

	Diðer yandan gizli bir baþka kabus hissettirmeden kendini gösterir ve sistem odalarýnýn soðuk atmosferinde sistem yöneticisinin zamanýný harcamaya baþlar. Bu sinsi uyumluluk problemi þöyle tarif edilebilir. Herhangi bir PC'deki bir uygulamayý bir þekilde o PC'ye/PC'den eriþebilen diðer bileþenlerden ayrý düþünmek imkansýzdýr. Yazýcý (Network üzerinde), internet eriþimi saðlayan router, mailleri tutan POP3 sunucu vb. Bütün bunlar bizim uygulamamýzýn yapýlandýrma kümesi içine giren bilgilerdir. Ýyi bir yapýlandýrma sistemi yerel kaynaklar kadar network üzerindeki kaynaklarý da yönetebilmeli, belli kurallar dahilinde onlarý da yapýlandýrabilmelidir. SNMP gibi bileþenler, maalesef ki bunu baþarmakta zorluk yaþamýþtýr. Sorun þudur, karmaþýklýk, kullanýcýya yatkýn bir arabirim tasarýmýný zorlaþtýrýr. Eðer, standart yapýlandýrma çerçevesi içine mevcut uygulamalarýn bu tür dýþ baðlantýlara müdahale edebilmesi için gereken altyapý hazýrlanabilirse bu sorunun çözümü için bir adým atýlabilecektir. Ayný þekilde, mevcut yerel kaynaklarýn uzak yönetimine de izin verebilen bir çerçeve oluþturulmalýdýr.

	Eðer, dýþ uygulamalarý tanýyabilecek, onlarý yapýlandýrabilecek ve/veya onlara göre kendi yapýlandýrmasýný düzenleyebilecek bir yapýlandýrma sistemi gerçekleþtirilebilirse sistemdeki kabiliyetleri kullanmak üzere gereken insan müdahelesi en aza inecek, bunun sonucunda da gizli kalmýþ kabiliyetlerin kendiliðinden kullanýmý yolu açýlacaktýr. Sonuçta, uygulamalarýn kullanýlabilir kabiliyetlerinin açýða çýkmasý, çok daha kolay kullaným saðlamak kadar, uygulamaya harcanan emeði de günyüzüne çýkarmak imkaný sunacaktýr.

	Buradaki kilit bileþen dýþ uygulamalarý tanýyabilmek ve yönetebilmek olmaktadýr. "Bu nasýl olacak, imkansýz" sorusu derhal karþýmýza çýkmaktadýr. Bunun çeþitli metotlarý olabilir:

	Çeþitli tanýma toollarý kullanmak: SMB protokolü, að üzerindeki yazýcý ve disk paylaþýmlarýný listeleyebilir. Benzer þekilde bazý bilgilerin çeþitli yöntemlerle elde edilmesi mümkündür. Yazýlým havuzu, bu tür iþlevleri yerine getirebilen pek çok uygulama barýndýrmaktadýr. Genede, pek çok bilginin bu yolla elde edilmesi mümkün deðildir. Bir yapýlandýrma yöneticisinin bu bilgiden istifade edebilmesini saðlayacak altyapýyý bulundurmasý gerekir. Bu yöntem bir kaynaðý bulmaya, o kaynaða göre eldeki uygulamayý bir yere kadar yapýlandýrmaya imkan tanýyabilir. Fakat, kaynaðýn mevcut sisteme uydurulmasý iþlevini saðlayamaz.

	Eriþilebilir haldeki kaynaklarýn kendilerini bulunabilir/kullanýlabilir hale getirilmesi: Kaynaklarý oluþturan uygulamalar ihtiyacý olan sistemlere sunulabilir. Bunun peer-to-peer olabilmesi, bir sistemdeki uygulamanýn diðerine ben buradayým/o þurada þeklinde tanýtýlmasý mümkün olduðu gibi, bu kaynaklarýn kendilerini merkezi bir otoriteye eklemeleri de mümkündür. Mevcut yöntemler (DNS vb.) bu iþlevi kolaylaþtýracaktýr.

	Kaynaklara eriþim/yönetim için özelleþtirilmiþ uygulamalar: Bir kaynak için, yerini belirlemek veya yeri bilinen kaynaðý uygun yapýlandýrma düzenine getirmek için gereken altyapýnýn saðlanmasý gerekir. Bu sayede, çeþitli þekillerde kaynaklarýn uyumlu olarak doðru yapýlandýrýlmasý mümkün olacaktýr. Bu durumu, ADSL modem ile örnekleyebiliriz. NAT özelliði ile yerel makinedeki WEB Sunucuyu internete açabiliriz. Sistem bu modeme örneðin HTML çaðrýsý yoluyla, otomatize olarak bu iþlevi yaptýrabilir. Böylece, WEB Server kurulunca, otomatikman ADSL modemi konfigüre edebilir. Bu özelliðin uygulanabilmesi için gereken altyapý yapýlandýrma yöneticisi üzerinde hazýr olmalýdýr.

	Bu gereksinimlere bakýnca, yapýlandýrma yöneticisinin devasa bir hal alacaðý düþünülmekte, tepkiler "bu bitmez" halinde olmaktadýr. Ýlk tepki, makul zamanýn mevcut zamandan çok daha fazla olduðu yönündedir. Ama görünmeyen asýl sorun, bir taraftan bu iþleri yapacak kodlar yazýlýrken sistemlerdeki bileþenlerin yol almaya devam edeceðidir. Sýk güncelleme gereksinimi, geliþtirici yükünü artýracak, oluþacak hatalar (dizayn ve implementasyon hatalarý) çevrime eklendikçe yapýlandýrma yöneticisinin bütünlüðünü saðlamak zorlaþacak, sonuçta bu tür bir proje hiç bir zaman sonlanmayacaktýr.

	Bu sorunu çözmenin bir yolu sistem kavramýna farklý bir bakýþ sunmaktýr. Öncelikle, yapýlandýrmalarýný yaptýðýmýz uygulama ve donanýmlarý, að üzerinde veya yerel makinede olduðuna bakmadan, "Kaynak" gibi bir belirtimle listelemek mümkündür. Örneðin yazýcý bir kaynaktýr. Að yazýcýsý olabildiði gibi, yerel yazýcýda olabilir. Ama bu bir 'yazýcý' dýr. Bu þekilde bir yaklaþýmla en jenerik halleriyle sistemdeki kaynaklar özetlenebilir. Devamýnda bu "kaynaklarýn" yapýlandýrma ihtiyaçlarý ve kullanabilmek için ihtiyaç duyulan bilgiler belirlenebilir. Belirlenen ihtiyaçlarda, makine tarafýndan iþlenebilecek bir formda ifade edilebilir.

	Bu süreçteki zorluk, kaynaklarýn adeta okyanus büyüklüðünde bir havuzu dolduracak kadar fazla ve her gün eklenen bileþenlerle dinamik bir sürece sahip olduklarý düþüncesidir. Bu, mutlak bir doðruluða sahiptir. Fakat, toplama ile her iþlemin yapýlabildiði gibi, uygun bakýþ açýsýyla en küçük sayýda kaynak tarifi ile en fazla ve geniþletilebilen bir liste oluþturulabilir.

	Bakýþ açýsý nasýl olmalý konusuna baktýðýmýzda, bir takým sistemler nasýl modellenmiþ bunlara gözatmak yeterli bir örnek olacaktýr. Bu tür bir kaynak listesi istendiði zaman akla hemen gelecek olan liste kabaca þuna benzeyecektir: "Yazýcý, ses kartý, modem, web server, ftp server, ldap server, mail server...". Bu listedeki en kolay örnek "Web Server..." silsilesidir.

	Eðer bir web serveri mercek altýna alýrsak, öncelikle bunun bir aða hizmet veren bir servis olduðunu görürüz. Mail Server, SMTP bölümüde ayný þekilde bir servistir. Eðer, web serveri öncelikle bir servis bileþenine ayýrýrsak, web serverin servis özelliklerini, web, html, http vs. gibi diger bileþenlerden anlamayan uygulamalarýn kullanýmýna sunabiliriz. Ayný þekilde, servis yapýsý ile SMTP, POP3 vs. her biri iþlenebilir. Elbette Layer 5+ özellikleri iþlenemeyecektir. Burada kaynak "Web Server" þeklinde tanýmlanýrsa, Layer 3-7 arasý pek çok taným ortaya çýkmaktadýr. Bu kadar kompleks tanýmlarýn her servis için tekrar edilmesi imkansýzdýr. Dahasý, biz o tanýmlarý yazarken, yeni bir servis de çýkacaktýr.

	Görüldüðü üzere, uygulamalar öncelikle fonksiyon gruplarýna baðlý olarak ele alýnmalýdýr. Doðru açýdan bakýnca pek çok bileþen netleþerek daha dar kapsamlý kaynak listesi ile iþlenebilir. Örneðin, virtualhost kavramýna bakabiliriz. Ýlk bakýþta bu kavramýn oturacaðý yer olarak 'web server' çýkýþý görülmektedir. Halbuki burada "host" kavramý web server tarafýndan deðil, adresleme sisteminin bir ürünüdür. Genel olarak host adlarý vs. name services denen sistemin bir parçasýdýr. VirtualHost ise, bu host'a ait adres üzerinde servisin iþletilmesidir. Bu baðýntý ilk bakýþta görülmese bile, her servisin bir baþka kaynaðý (burada bir dizindeki dosyalar) bir veya birkaç host için hizmete aldýðý açýkça görülebilir. Kýsaca, servis tanýmýna eðer servisin hizmetini verdiði kaynak ve adres (host) bilgisi de eklenirse, virtual host gibi bir kaynak tanýmlamak gerekmeden bu iþlev yapýlabilir. Ayný þekilde, mail virtual domain'leri v. hepsi de gerçeklenebilir. Ve bunlarý ifade etmek üzere tek bir servis jenerik kaynaðý tarif edilebilir.

	Doðru bakýþ açýsý, mevcut alýþkanlýklarý býrakýp "Bu nasýl iþliyor gerçek dünyada ?" sorusunu sormayý gerektirmektedir. Web server iyi bir örnektir. Basitçe bir servis nesnesi çýkarabiliriz. Fakat gerçek dünyada her zaman olmasa bile web serverin önüne bir proxy eklenmesi durumuna rastlarýz. Bu ender bir durumdur ama mümkündür. Ayrýca bazý gereksinimler için en uygun çözümdür. Örnek olarak bu durumda sayfalar bazýnda yük dengeleme ve/veya servis seçme imkaný sunulabilir. Bu bir yol ayrýmýný getirir. Eðer biz proxy gibi uygulamalarý servis denetleyici olarak atar, asýl servisleri ise bunlarýn arkasýnda çalýþabilir halde dizayn edersek, bu gücü açýða çýkarma imkanýný saðlamýþ oluruz.

	Ýþte benzer þekilde, uygulama özelliklerinden baðýmsýz olarak sistemde ne var ne yok bakýþýyla, sadece makine bazýnda deðil, tüm çevreyi düþünerek hazýrlanacak bir kaynak listesi ve bunlara dair yapýlandýrma metodolojisini tanýmlayabilirsek, bu tanýmlarý doldurmak mümkün olacaktýr.

	COMAR Nesne Modeli, bu kaynak listesi ve yapýlandýrma modelini ifade etmektedir. Bu model temel olarak hiç bir uygulamayý ifade etmez. Model iki farklý yönelim sunmaktadýr. Bir yandan bir kaynak hakkýnda gereken bilgiyi edinme görevini karþýlarken ayný zamanda ilgili kaynaðý istenen þekilde yapýlandýrabilme imkanýný da sunar. Kaynak uzak veya yerel olabilir, birden fazla uygulama tarafýndan karþýlanýyor olabilir. Bu ve benzeri sorunlarýn çözümü COMAR Tarafýndan yapýlýr. Fakat, bu kaynaðýn yapýlandýrmasý ve bilginin saðlanmasý uygulama tarafýndan saðlanýr. Uygulamalarýn bu modele birebir uymasý umulamaz. Fakat konfigürasyon parametrelerini okuyan, deðiþtiren vb. yollarla uygulamanýn sisteme adapte edilmesini saðlamak imkan dahilindedir. Unutulmamasý gereken husus, bir uygulama bir kaynak ile eþleþmeyebilir. Çeþitli fonksiyonaliteleri çeþitli ve farklý kaynaklara tekabül edebilir.

COMAR Bileþenleri:

	COMAR, üç temel bileþen ve bunlara yardýmcý olan alt bileþenlerden oluþur. Mevcut implementasyonda bu bileþenler Python ile gerçeklenmiþtir. Fakat, bileþenler ve nesneler arasýnda

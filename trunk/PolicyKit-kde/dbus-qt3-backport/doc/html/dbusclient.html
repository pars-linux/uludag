<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>dbus-qt3-backport: Using DBus as a client</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
  </ul>
</div>
<h1><a class="anchor" name="dbusclient">Using DBus as a client </a></h1>Contents:<ul>
<li><a class="el" href="dbusclient.html#dbusclient-introduction">Introduction</a></li></ul>
<p>
<ul>
<li><a class="el" href="dbusclient.html#dbusclient-example">A simple DBus client example</a></li></ul>
<p>
<ul>
<li><a class="el" href="dbusclient.html#dbusclient-initialization">Program initialization</a></li></ul>
<p>
<ul>
<li><a class="el" href="dbusclient.html#dbusclient-methodcall">Method invocation</a><ul>
<li><a class="el" href="dbusclient.html#dbusclient-synccall">Synchronous method calls</a></li><li><a class="el" href="dbusclient.html#dbusclient-asynccall">Asynchronous method calls</a></li></ul>
</li></ul>
<p>
<ul>
<li><a class="el" href="dbusclient.html#dbusclient-signals">Connecting to DBus signals</a><ul>
<li><a class="el" href="dbusclient.html#dbusclient-signals-example">Signal example</a></li></ul>
</li></ul>
<h2><a class="anchor" name="dbusclient-introduction">
Introduction</a></h2>
While it is of course possible to just exchange DBus messages with a DBus service, it is a lot more comfortable to use <a class="el" href="classQDBusProxy.html" title="Client interface to a remote service object.">QDBusProxy</a>.<p>
With <a class="el" href="classQDBusProxy.html" title="Client interface to a remote service object.">QDBusProxy</a> you only need to specify the service object once, i.e. its DBus name, path and interface, and just provide the method and its parameters when initiating an invokation.<p>
Additionally the proxy transforms DBus signals from the proxy's peer (the DBus service object's interface it is associated with) to QObject signal carrying the original signal's content.<h2><a class="anchor" name="dbusclient-example">
A simple DBus client example</a></h2>
<div class="fragment"><pre class="fragment"><span class="preprocessor">   #include &lt;<a class="code" href="qdbusconnection_8h.html">dbus/qdbusconnection.h</a>&gt;</span>
<span class="preprocessor">   #include &lt;<a class="code" href="qdbusmessage_8h.html">dbus/qdbusmessage.h</a>&gt;</span>
<span class="preprocessor">   #include &lt;<a class="code" href="qdbusproxy_8h.html">dbus/qdbusproxy.h</a>&gt;</span>

   <span class="keywordtype">int</span> main()
   {
       <span class="comment">// establish a connection to the session bus</span>

       <a class="code" href="classQDBusConnection.html" title="Provides access to a specific DBus bus.">QDBusConnection</a> connection =
           <a class="code" href="classQDBusConnection.html#293af4d19e3eb1950cdd3f954a1ae200" title="Add a connection to a bus with a specific bus type.">QDBusConnection::addConnection</a>(<a class="code" href="classQDBusConnection.html#44a8f0309154c8a61286a27eb224e8e1f4816dbeb082e50baa7e6d16b5b48b4d">QDBusConnection::SessionBus</a>);

       <span class="keywordflow">if</span> (!connection.<a class="code" href="classQDBusConnection.html#f6ab163c6e5d0ded0787a55b098bce62" title="Returns whether the connection is connected to a bus.">isConnected</a>())
           qFatal(<span class="stringliteral">"Failed to connect to session bus"</span>);

       <span class="comment">// create a proxy object for method calls</span>

       <a class="code" href="classQDBusProxy.html" title="Client interface to a remote service object.">QDBusProxy</a> proxy(connection);
       proxy.setService(<span class="stringliteral">"org.freedesktop.DBus"</span>);   <span class="comment">// who we work with</span>
       proxy.setPath(<span class="stringliteral">"/org/freedesktop/DBus"</span>);     <span class="comment">// which object inside the peer work with</span>
       proxy.setInterface(<span class="stringliteral">"org.freedesktop.DBus"</span>); <span class="comment">// which of its interfaces we will use</span>

       <span class="comment">// call the "ListNames" method. It returns an array of string, in Qt3 terms</span>
       <span class="comment">// a QStringList, it expects no parameters</span>

       QValueList&lt;QVariant&gt; params;
       <a class="code" href="classQDBusMessage.html" title="A message converts and transports data over DBus.">QDBusMessage</a> reply = proxy.sendWithReply(<span class="stringliteral">"ListNames"</span>, params);

       <span class="keywordflow">if</span> (reply.<a class="code" href="classQDBusMessage.html#f82b589a030579b9f1aa3a8822641419" title="Returns which kind of message this is.">type</a>() != <a class="code" href="classQDBusMessage.html#99ffac3ccf917a669ad01a63336d717b636272d52beaeea95861b60409286498">QDBusMessage::ReplyMessage</a>)
           qFatal(<span class="stringliteral">"Call failed"</span>);

       <span class="keywordflow">if</span> (reply.count() != 1 || reply[0].<a class="code" href="classQDBusMessage.html#f82b589a030579b9f1aa3a8822641419" title="Returns which kind of message this is.">type</a>() != QVariant::StringList)
           qFatal(<span class="stringliteral">"Unexpected reply"</span>);

       QStringList names = reply[0].toStringList();
       <span class="keywordflow">for</span> (QStringList::iterator it = names.begin(); it != names.end(); ++it)
       {
           qDebug(<span class="stringliteral">"%s"</span>, (*it).local8Bit().data());
       }

       <span class="keywordflow">return</span> 0;
   }
</pre></div><h2><a class="anchor" name="dbusclient-initialization">
Program initialization</a></h2>
A connection to the bus is acquired using <a class="el" href="classQDBusConnection.html#293af4d19e3eb1950cdd3f954a1ae200" title="Add a connection to a bus with a specific bus type.">QDBusConnection::addConnection()</a><p>
Next, a proxy is created for the object <code>"/org/freedesktop/DBus"</code> with interface <code>"org.freedesktop.DBus"</code> on the service <code>"org.freedesktop.DBus"</code> <p>
This is a proxy for the message bus itself.<h2><a class="anchor" name="dbusclient-methodcall">
Method invocation</a></h2>
There are two choices for method invocation:<ul>
<li>sychronous (blocking) calls</li><li>asynchronous (non-blocking) calls</li></ul>
<h3><a class="anchor" name="dbusclient-synccall">
Synchronous method calls</a></h3>
As seen in the example code above, a synchronous method call can be achieved by <a class="el" href="classQDBusProxy.html#61dc3b418a56affdfd9f586fce315280" title="Sends a method call to the peer object and waits for the reply.">QDBusProxy::sendWithReply()</a>. It sends a method call to the remote object, and blocks until reply is received. The outgoing arguments are specified as a list of QVariants.<h3><a class="anchor" name="dbusclient-asynccall">
Asynchronous method calls</a></h3>
To invoke a method asynchronously, connect the proxy's signal <a class="el" href="classQDBusProxy.html#884668d72219475bf0378e7e73c74c40" title="Signal emitted for received replies to asynchronous method calls.">QDBusProxy::asyncReply(int, const QDBusMessage&amp;)</a> to a suitable slot like with any other Qt Signal-Slot connection.<p>
Then call <a class="el" href="classQDBusProxy.html#5654ec9c379d7fb5840ba992e472a974" title="Sends a method call to the peer object but does not wait for an answer.">QDBusProxy::sendWithAsyncReply()</a> It returns a numerical identifier of the call, so it can be related in the slot once the result is available.<p>
The slot's first argument is the reveived reply's call identifier as returned by the method call. The second parameter is the reply message similar to the one in the synchronous call.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>For asynchronous calls you'll need a running event loop, i.e. a QApplication object and its exec() having been invoked.</dd></dl>
<h2><a class="anchor" name="dbusclient-signals">
Connecting to DBus signals</a></h2>
To receive D-BUS signals just connect to the QDBusProxy's signal <a class="el" href="classQDBusProxy.html#6da8694c00848352284f08d0a6f232a9" title="Signal emitted for DBus signals from the peer.">QDBusProxy::dbusSignal(const QDBusMessage&amp;)</a><p>
It will be emitted whenever a DBus signal message is received from the peer object. Filtering of signals is based on the value set for <code>service</code>, <code>path</code> and <code>interface</code> <p>
Usually a proxy will be also be used to send to the peer object, thus having them all set. However if a proxy is only needed for signals, any of the three properties can be omitted (e.g. set to <code>QString::null</code> ), in which case only the available properties will be checked against the respective message field when deciding about dropping or emitting the message. See <a class="el" href="classQDBusProxy.html#b905df72488825e5022abc74adda23e7" title="Handles DBus signals received on the proxy&#39;s connection.">QDBusProxy::handleDBusSignal()</a><p>
If you want all signal travelling on the bus, or apply filtering for different criteria, e.g. get all signals coming from interfaces starting with <code>"org."</code>, use <code><a class="el" href="classQDBusConnection.html#915588ac46028dace802f1933de9d07e" title="Connects an object to receive DBus signals.">QDBusConnection::connect()</a></code> instead. The signature of the slot stays the same.<h3><a class="anchor" name="dbusclient-signals-example">
Signal example</a></h3>
First declare a receiver class: <div class="fragment"><pre class="fragment">   <span class="keyword">class </span>MyReceiver : <span class="keyword">public</span> QObject
   {
       Q_OBJECT
   <span class="keyword">public</span> slots:
       <span class="keywordtype">void</span> handleDBusSignal(<span class="keyword">const</span> <a class="code" href="classQDBusMessage.html" title="A message converts and transports data over DBus.">QDBusMessage</a>&amp;);
   };
</pre></div> Then somewhere else in a source file: <div class="fragment"><pre class="fragment">   <a class="code" href="classQDBusConnection.html" title="Provides access to a specific DBus bus.">QDBusConnection</a> connection = <a class="code" href="classQDBusConnection.html#293af4d19e3eb1950cdd3f954a1ae200" title="Add a connection to a bus with a specific bus type.">QDBusConnection::addConnection</a>(<a class="code" href="classQDBusConnection.html#44a8f0309154c8a61286a27eb224e8e1f4816dbeb082e50baa7e6d16b5b48b4d">QDBusConnection::SessionBus</a>);

   MyReceiver* receiver1 = <span class="keyword">new</span> MyReceiver();

   connection.<a class="code" href="classQDBusConnection.html#915588ac46028dace802f1933de9d07e" title="Connects an object to receive DBus signals.">connect</a>(receiver1, SLOT(handleDBusSignal(<span class="keyword">const</span> <a class="code" href="classQDBusMessage.html" title="A message converts and transports data over DBus.">QDBusMessage</a>&amp;)));
</pre></div> <code>receiver1</code> will get all signals on this connection<p>
<div class="fragment"><pre class="fragment">   <a class="code" href="classQDBusProxy.html" title="Client interface to a remote service object.">QDBusProxy</a>* proxy = <span class="keyword">new</span> <a class="code" href="classQDBusProxy.html" title="Client interface to a remote service object.">QDBusProxy</a>(connection);
   proxy-&gt;<a class="code" href="classQDBusProxy.html#4fba391a291ba48771d6d646d3614417" title="Sets the peer&amp;#39;s service name.">setService</a>(<span class="stringliteral">"org.freedesktop.DBus"</span>);   <span class="comment">// who we work with</span>
   proxy-&gt;<a class="code" href="classQDBusProxy.html#4d380c57af03ff2d06b16acb081cd388" title="Sets the peer&amp;#39;s object path.">setPath</a>(<span class="stringliteral">"/org/freedesktop/DBus"</span>);     <span class="comment">// which object inside the peer work with</span>
   proxy-&gt;<a class="code" href="classQDBusProxy.html#39ab62a25279c780590eeb55137a407b" title="Sets the name of the peer interface.">setInterface</a>(<span class="stringliteral">"org.freedesktop.DBus"</span>); <span class="comment">// which of its interfaces we will use</span>

   MyReceiver* receiver2 = <span class="keyword">new</span> MyReceiver();

   QObject::connect(proxy,     SIGNAL(dbusSignal(<span class="keyword">const</span> <a class="code" href="classQDBusMessage.html" title="A message converts and transports data over DBus.">QDBusMessage</a>&amp;)),
                    receiver2, SLOT(handleDBusSignal(<span class="keyword">const</span> <a class="code" href="classQDBusMessage.html" title="A message converts and transports data over DBus.">QDBusMessage</a>&amp;)));
</pre></div> <code>receiver2</code> will only get signals coming from the proxy's peer interface <hr size="1"><address style="text-align: right;"><small>Generated on Sat Jan 12 13:15:01 2008 for dbus-qt3-backport by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.4 </small></address>
</body>
</html>

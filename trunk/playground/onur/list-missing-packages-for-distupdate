#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Dist Update planner using pisi api and piksemel
# This script resides because we need to check if we can
# update, to find out what is missing for update etc.
# without adding new distro repo / upgrading any packages
#

import os
import sys

import bz2
import lzma # install python-pyliblzma if you are using Pardus 2009
import urllib2

import piksemel
import pisi

defaultNextRepoURI = "http://packages.pardus.org.tr/pardus/2011/testing/i686/pisi-index.xml.xz"
forceInstallPackages = "http://svn.pardus.org.tr/uludag/trunk/pardus-upgrade/2009_to_2011.list"
DEBUG = False


def printDebug(dbgstr):
    if DEBUG:
        print dbgstr

def uniq(i):
    return list(set(i))

def getIndex(uri):
    printDebug("* Getting index from %s" % uri)

    try:
        if "://" in uri:
            rawdata = urllib2.urlopen(uri).read()
        else:
            rawdata = open(uri, "r").read()
    except IOError:
        print "could not fetch %s" % uri
        return None

    if uri.endswith("bz2"):
        data = bz2.decompress(rawdata)
    elif uri.endswith("xz") or uri.endswith("lzma"):
        data = lzma.decompress(rawdata)
    else:
        data = rawdata

    printDebug("  done")
    return data

def convertToRepoDB(ix):
    printDebug("* Converting package objects to db object")

    doc = piksemel.parseString(ix)
    dbobj = pisi.index.Index()
    dbobj.decode(doc, [])

    printDebug("  done")
    return dbobj

def parseRepoIndex(_file):
    printDebug("* Parsing repo index of %s" % _file)

    pkgprop = {}
    obsoletelist = []
    ix = piksemel.parseString(getIndex(_file))

    obsoleteParent = ix.getTag("Distribution").getTag("Obsoletes")
    for node in obsoleteParent.tags("Package"):
        obsoletelist.append(node.firstChild().data())

    for i in ix.tags("Package"):
        replaceslist = []

        pkgName = i.getTagData("Name")
        pkgURI = i.getTagData("PackageURI")
        pkgSize = i.getTagData("PackageSize")
        pkgHash = i.getTagData("PackageHash")
        pkgInstalledSize = i.getTagData("InstalledSize")

        replacedPackages = i.getTag("Replaces")

        if replacedPackages:
            for replaced in replacedPackages.tags("Package"):
                replaceslist.append(replaced.firstChild().data())

        pkgprop[pkgName] = [replaceslist, pkgURI, pkgSize, pkgInstalledSize, pkgHash]

    printDebug("  found %d packages and %s obsoletelist" % (len(pkgprop.keys()), len(obsoletelist)))

    return pkgprop, obsoletelist

def getInstalledPackages():
    printDebug("* Getting installed packages")

    a = pisi.api.list_installed()
    a.sort()

    printDebug("  found %d packages" % len(a))

    return a

def getForceInstallPackages():
    printDebug("* Getting force install packages")

    pkglist = urllib2.urlopen(forceInstallPackages).read().split()

    return pkglist

def getInstalledSize(installedPackages):
    printDebug("* Calculating installed size of installed package")

    totalsize = 0
    idb = pisi.db.installdb.InstallDB()

    for i in installedPackages:
        pkg = idb.get_package(i)
        totalsize += pkg.installedSize
        #print "%-30s %s" % (pkg.name, pkg.installedSize)

    printDebug("  total size = %d" % totalsize)

    return totalsize

def getDistroDiff(installed, nextRepo, obsoletes):
    printDebug("* Calculating package differences of old and new repos")

    pkglist = []
    replacedBy = {}
    neededPackages = []

    # we make a cache of replaced packages, not to iterate over and over on package dict
    for i in nextRepo:
        pkglist.append(i)
        for r in nextRepo[i][0]:
            pkglist.append(r)
            if r in replacedBy:
                replacedBy[r].append(i)
            else:
                replacedBy[r] = [i]

    # and we package list of removed (replaced + obsoleted) packages
    pkglist.extend(obsoletes)
    uniqpkglist = uniq(pkglist)

    for i in installed:
        if i not in uniqpkglist:
            neededPackages.append(i)

    printDebug("  found %d obsoleted and replaced packages" % len(neededPackages))

    return neededPackages

def findMissingPackagesForDistupdate(nextRepoURI):
    printDebug("* Find missing packages for distupdate ")

    # parseRepoIndex returns dictionary as package[NAME] = [Replaces, PISIfile, Size, Installedsize, Checksum]
    # and obsoleted package name list as second arg
    nextRepo, nextRepoObsoletes = parseRepoIndex(nextRepoURI)
    installedPackages = getInstalledPackages()

    neededPackages = getDistroDiff(installedPackages, nextRepo, nextRepoObsoletes)

    if len(neededPackages):
        printDebug("  found packages preventing distupdate")
        printDebug(neededPackages)
    else:
        printDebug("  distupdate is good to go")

    return neededPackages

def resolveDependencies(A, pkgdb):
    printDebug("* Plan dependencies for newly installing packages")

    # this would be the system package db on a normal scenario
    # packagedb = pisi.db.packagedb.PackageDB()

    # repodict = dict((pkg.name, pkg) for pkg in pkgdb.packages)
    repodict = dict((pkg.name, pkg) for pkg in pkgdb.packages)

    # our lovely fake package db, we need to make up one since
    # we are working on a repository that is not added to system
    class PackageDB:
        def get_package(self, key, repo = None):
            return repodict[str(key)]

    packagedb = PackageDB()

    # write package names as a list for testing
    # A = repodict.keys()

    # construct G_f
    G_f = pisi.pgraph.PGraph(packagedb)

    # find the install closure graph of G_f by package
    # set A using packagedb
    for x in A:
        G_f.add_package(x)

    B = A
    while len(B) > 0:
        Bp = set()
        for x in B:
            pkg = packagedb.get_package(x)
            for dep in pkg.runtimeDependencies():
                printDebug("  checking %s" % str(dep))

                if not dep.package in G_f.vertices():
                    Bp.add(str(dep.package))
                G_f.add_dep(x, dep)

        B = Bp

    order = G_f.topological_sort()
    order.reverse()

    return G_f, order


def planDistUpdate(targetRepo=defaultNextRepoURI):
    printDebug("* Planning the whole distupdate process")

    #installtest = ["firefox"]

    # installed packages
    currentPackages = getInstalledPackages()

    # new packages needed for the new distro version
    newDistroPackages = getForceInstallPackages()
    currentPackages.extend(newDistroPackages)

    currentPackages = uniq(currentPackages)

    # packages that has not been taken care of
    missingPackages = findMissingPackagesForDistupdate(targetRepo)

    indexstring = getIndex(targetrepo)
    repodb = convertToRepoDB(indexstring)

    graphobj, order = resolveDependencies(currentPackages, repodb)

    print order


if __name__ == "__main__":
    DEBUG = True

    if len(sys.argv) > 1:
        targetrepo = sys.argv[1]
    else:
        # targetrepo = "pisi-index.xml"
        targetrepo = defaultNextRepoURI

    planDistUpdate(targetrepo)



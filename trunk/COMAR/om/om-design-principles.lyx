#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass article
\language turkish
\inputencoding auto
\fontscheme pslatex
\graphics default
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

Yapýlandýrma Sistemi Tasarýmý için Prosedür
\layout Author

Dürtücü Teknolojiler Ar-Ge Labs.
\layout Standard


\begin_inset LatexCommand \tableofcontents{}

\end_inset 


\layout Section
\pagebreak_top 
Görev Analizi
\layout Standard

Bu analiz, "sistem yapýlandýrmasý" denen görevin nesnel yapýsýný ihtiva
 edecek OM nesnelerinin çýkarýlmasýný amaçlar.
\layout Subsection

Proje Nesne Modeli (User View Objects, PDC):
\layout Standard

Bu model, projenin temel yapýtaþý olan nesneleri, kod þeklinde olmadan 'real-wor
ld' yapýsý içinde modeller..
 Bu nesneleri çýkarmak için 'anahtar soru yöntemi' uygun olabilir.
 Yourdon bu soruyu þöyle sormaktadýr: "What things (real or abstract) does
 the business care enough about to store about them ?".
 Bu soruyu biz "yapýlandýrma ihtiyacý gösteren en küçük, ihtiyaca yönelik
 olaraksa en geniþ veriyi tutan" þeklinde adapte edebiliriz.
 Bu süreç boyunca tanýmlanacak nesneler için þu bileþenler not edilmelidir:
\layout Itemize

Nesnenin adý
\layout Itemize

Nesnenin ana (major) attribute'leri
\layout Itemize

Kýsa bir taným cümlesi
\layout Standard

Uygulanacak yol ise kýsaca þu adýmlardan ibaret olabilir:
\layout Itemize

Candidate PDC object (CO)'leri belirleyin.
 Burada 6 kural geçerlidir: 
\begin_deeper 
\layout Description

Necessary\SpecialChar ~
Remembrance: Make certain that the proposed object has some data
 that it must remember.
\layout Description

More\SpecialChar ~
Than\SpecialChar ~
One\SpecialChar ~
Attribute: Eðer bir tek attr/method varsa bu nesne büyük ihtimalle
 baþka bir nesnenin bir attribute'üdür.
\layout Description

Needed\SpecialChar ~
Functionality: Nesne sadece veri anlamýna gelmemeli, bu veriyle bir
 (veya daha fazla) iþlev yapabilmelidir.
\layout Description

Essential\SpecialChar ~
Functionality: Software/hardware vs.
 limitleri düþünülmeden, ne gibi iþlevsellik bekliyoruz sorusuna cevap bulunmalý
dýr.
 Implementasyon detayý olan konular, ilerki safhalarda ele alýnmalýdýr.
\layout Description

Common\SpecialChar ~
Attributes: Her instance ayný attribute'leri kullanmalýdýr.
 Þu tür instance'lar için bu attribute seti gibi tavýrlardan kaçýnýlmaldýr.
\layout Description

Common\SpecialChar ~
Functionality: Her instance için ayný fonksiyonelite saðlanmalýdýr.
 Bu 6 kalem liste, Rumbaugh tarafýndan önerilirken özellikle þu iki husus
 önemle vurgulanýr: "Nesne tanýmý (CO) gerçekten bir nesne olmalýdýr, bir
 fonksiyon veya property deðil" ve "Overlapped/duplicated nesnelerden sakýnýnýz".
 
\end_deeper 
\layout Itemize

Bu nesneleri mümkünse özet nesne sýnýflarý þekline getirin.
 
\layout Itemize

Bu nesneler arasýndaki statik baðýntýlarý (relationship) belirleyin.
 Bu iþlem genellikle (n * (n-1)) / 2 Formülü ile sonuçlanan bir süreçtir.
 Sonuçta nesneler arttýkça aralarýndaki baðlantýlarda böyle artacaktýr.
 Bunu engellemenin kesin bir yolu yoktur.
 Fakat bu baðlantýlar bilhassa nesneleri kullanacak olan kullanýcý için
 önem taþýmaktadýr.
 Þöyleki, baðlantý iki nesne arasýnda yapýlan iþlemin fiilini tanýmlamaktadýr:
 "Müþteri (nesnesi) ürün (nesnesi) alýyor" ise, baðýntý "almak" eylemidir.
 Bu durumda bizim uygulamamýz özelinde, düþündüðümüz nesnenin fiili kabiliyetler
i baðýntýlarý gösterecektir: "Ekle, sil, gönder, oku, ara..." gibi.
 Burada püf noktasý, baðýntýlarýn iki nesne arasýnda tarif edilmiyor olmasýdýr.
 Buna mukabil, bilhassa alt sistem nesneleri arasýnda bazý önceden bilinmesi
 gereken baðýntýlar olmasý muhakkaktýr.
 Tipik OO modellerindeki, derived, N-Array, Recursive gibi baðlantýlar bizim
 için makul deðillerdir.
 Eðer iki nesne arasýnda bir baðlantý tarif edilmiþse, bu baðlantýnýn cardinalit
y'si tarif edilmelidir: Yön, [1:N|N:N|N:1] ve Min/Max deðerleri.
\layout Standard

Sýk yapýlan bir yanlýþ, "macho" yaklaþýmý olmaktadýr: "Benim OO modelim
 seninkinden daha iyi, çünkü daha çok CO belirledim".
 Bunun sonucu genellikle bürokrasiyi artýrýp uygulamayý devlet dairesine
 benzetmekle sonuçlanýr, yazýlým iþi zaten buna ihtiyaç duyulmayacak kadar
 zordur.
\layout Standard

Nesnenin attribute'lerini belirlerken, özellikle bu nesneyi ana hatlarý
 ile anlamayý ve diðerlerinden ayýrmayý saðlayan bileþenlerin seçilmesi
 yeterli ve þart koþuldur.
\layout Standard

Statik baðlantýlarýn keþfedilmesi için en uygun yöntem, nesnenin diðer nesne
 tarafýndan çaðrýlmasýný ifade eden cümleler kurmaktýr.
 Bu cümlelerin yüklemleri bize statik baðýntý noktasýný kolayca gösterecektir.
 Burada, unutulmamasý gereken husus bunun bir uygulama data yapýsý olmadýðý,
 tanýmýn "real-world" yapýsý içinde tarifinin yeterli olduðudur.
\layout Itemize

Tarif Edilen nesneler problem domain'in çerçevesi (scope) içinde tanýmlanýyor
 mu?
\layout Itemize

Bu nesneler hizmetlerini belirten þekilde adlandýrýlmýþ mý?
\layout Itemize

Herhangi bir nesne diðerinin sahasýnýn üzerine giriyor mu (Overlapped Objects)?
\layout Itemize

Ayný iþi yapan birden fazla nesne var mý (Duplicated Objects)?
\layout Itemize

Nesneler arasýndaki baðýmlýklar (Baðlantýlar deðil) tarif edilmiþmi?
\layout Itemize

Nesneler arasýndaki baðlantýlar tespit edilmiþ mi?
\layout Itemize

Baðlantýnýn yönü, diðer baðlantýlarla kesiþmeleri doðru mu?
\layout Itemize

Her baðlantý düzgünce adlandýrýlmýþ mý, "cardinality" ve "enumeration" tespit
 edilmiþ mi?
\layout Itemize

Burada hangi deðerler (attributes) kullanýcýya yönelik olacak (Kullanýcý,
 uygulama geliþtirici, son kullanýcý vs.).
\layout Subsection

Nesnelerin hayat döngüsü
\layout Standard

Hayat döngüsü, bir nesnenin yaþamaya baþladýðý andan itibaren diðer nesnelerle
 olan etkileþimleri ve bu etkileþimler sonucunda oluþan durum (state) deðiþimler
ini, bu deðiþimlerin oluþturduðu olaylarý ve elde edilen sonucu diyagram
 olarak tarif eder.
\layout Standard

Hayat döngüsü (Life Cycle), nesnelerin hangi zamanda hangi durumda olduðunu
 anlamayý kolaylaþtýrýr.
 Bir nesnenin ne zaman çaðrýlacaðý, sistem yapýlandýrmasýnda son derece
 bulanýk bir yapý oluþturur.
 Fakat, bazý belirli fazlar net bir þekilde çýkarýlabilir.
 Örneðin nesneyi sunan uygulamanýn ilk kurulum aný gibi.
 Burada bize gerekli olan diagram aslen öncelikle bir nesnenin iþlendiði
 süreç olacaktýr.
 Bu kabaca, uygun instance'ýn elde edilmesi, uygun parametrelerle iþlenmesi
 gibi daha ziyade tek bir nesneye yönelik olacaktýr.
\layout Standard

Bu diagramýn bir çizimle somut hale getirilmesi anlaþýlmasýný kolaylaþtýracaktýr.
 Bu noktada aþaðýdaki adýmlarýn takip edilmesi kolaylýk saðlayabilir:
\layout Itemize

Bu nesnenin bir state modeli var mý? (her nesne belirli bir state'e sahip
 olmak zorunda deðildir; transient olabilen nesnelerde bulunabilir; bu durumda
 nesnenin life-cycle modelini çýkarmaya gerek olmayacaktýr)
\layout Itemize

Nesnenin ilk state'i nedir?
\layout Itemize

Nesnenin ilk state'ini deðiþtirerek instance oluþturmasý veya ilk durumuna
 geçmesi için gereken nasýl bir event/mesaj tanýmlanabilir?
\layout Itemize

Baþka hangi olaylar bu nesnenin state'ini deðiþtirebilir?
\layout Itemize

Bu deðiþiklik aslen hangi attribute'ler tarafýndan ifade edilebilir?
\layout Itemize

Nesne ne zaman ortadan kalkacaktýr, bu hangi attribute'leri etkiler ?
\layout Standard

Bu adým için uygun bir checklist þu þekilde hazýrlanabilir:
\layout Itemize

Her yeni duruma geçiþ için alýnacak event belirlenmiþ mi?
\layout Itemize

Her durumda eventlere verilecek cevaplar belirlenmiþ mi?
\layout Itemize

Nesnenin tüm durumlarý mutual olarak tanýmlanmýþ mý?
\layout Itemize

Her bir durum düzgünce adlandýrýlýp tarif edilmiþ mi ?
\layout Itemize

Durum deðiþiklikleri düzgün þekilde, diðer nesnelere göre iþaretlenmiþ mi?
\layout Itemize

Her durum için nesnenin alabileceði eventler belirlenmiþ mi?
\layout Itemize

Her bir geçiþte, sonuç durumu gerçekten istenen durummu?
\layout Subsection

Kullaným süreci
\layout Standard

Kullaným süreci, kullanýcýnýn bu sistemi nasýl kullanacaðýný ifade eder.
 Bu süreç, bir giriþ bilgisi alýp kullanýcýya elde edebildiði diðer bilgiyi
 de kullanarak bir deðer üretmelidir.
 Bu süreç bazý durumlarda nesnelerin state'ini deðiþtirebilecektir.
 Süreçler, nesneler bazýnda teker teker deðil, bir örnek süreç için hangi
 nesneden baþlanarak elde edilecek veri ile istenen deðeri elde etmek üzere
 hangi nesnelerin nasýl iþletileceðini belirlemek þeklinde olacaktýr.
 Hayat döngüsündeki durumlar arasýnda geçiþler için seçilecek örnek süreç
 ve bunlardan çýkarýlacak alt süreçler, baðýntýlarýn tespiti, öngörülmemiþ
 yeni state'lerin tespiti gibi faydalar saðlayacaktýr.
 Bu sayede, "Proje nesne modeli" ve "Nesnelerin hayat döngüsü" çalýþmalarýnýn
 bu süreçler ile birlikte iteratif olarak yürütülmesi, her adýmda elde edilen
 yeni yapýlarýn uygun checklistler ile kontrol edilerek geniþletilmesi,
 "sistem gerekleri"ne baþlamak üzere gereken bilgiyi saðlayacaktýr.
\layout Standard

OM modelinde belirli bir süreç akýþ modeli olmadýðý düþünülürse, bu adýmýn
 gerekli nesneleri çeþitli use-case'ler aracýlýðýyla anlamaya, nesneler
 arasýndaki iliþkileri tanýmlamaya yardýmcý bir adým olduðu akýlda tutulmalýdýr.
\layout Itemize

Tarif edilen süreç, bir veya bir kaç giriþ bilgisi alýp, kullanýcýya bir
 çýktý sunuyor mu?
\layout Itemize

Bu süreç, nesne modelinde hangi event sekansýný baþlatýyor?
\layout Itemize

Hayat döngüsünde doðru bir sekans giriþi var mý?
\layout Itemize

Bir süreçler dizisi belirlenmiþse, farklý diziler için farklý event sekansý
 tarif edilmiþ mi, bu tür sekanslarýn temizlenmiþ mi?
\layout Itemize

Süreç için belirli bir nesne state'i zorunluluðu varmý (varsa temizlenmeli)?
\layout Itemize

Bir süreç nesnelerde durum geçiþlerine yol açmadan sonuçlanabiliyor mu?
 (eðer bir transient nesne deðilse, süreç geçersizdir, kaldýrýn).
\layout Section

Sistem gerekleri (Esas Nesne Modelinin Çýkarýlmasý)
\layout Standard

Sistem gerekleri, görev analizine bakarak bu sistem için hangi bileþenler
 gerekiyor listesinin çýkarýlmasýdýr.
 Standart programlama modellerinde süreçler ve bunlarýn alt süreçleri bir
 aktivite'ye tekabül eder.
 Örneðin, fatura kesilmesi, bir satýþ aktivitesidir.
 Bu aktivitede stok nesneleri, cari nesneleri, yazdýrma nesneleri vs.
 uygun noktada devreye girerler.
 Halbuki yapýlandýrma modelinin getirdiði sistem nesnelerinin ne zaman baþlayýp
 biteceði, hangi nesneden interaction ile baþlatýlacaðý kestirilememektedir.
\layout Standard

Hazýrlanmýþ olan alt sistemler ve sistem modeli dökümanlarý üzerinden Görev
 analizi yeterince saðlýklý yapýlabildiði gibi, nesnelerin olasý kullaným
 durumlarý gözönüne alýnarak alt sistem bazýnda gereken bileþenler çýkarýlabilir.
\layout Standard

Sistem gerekleri ile elde edilecek olan sonuç, gerekli olan Object Model'in
 tam bir reprezantasyonu olacaktýr.
\layout Standard

Temel olarak bu süreç aþaðýdaki alt baþlýklar ile özetlenebilir.
\layout Subsection

System Transaction Sequence Diagrams:
\layout Standard

Booch'un bu aþama için, "Kompleks prodüksiyon sistemleri aslen az sayýda
 olan senaryo (use-case) üzerinde gerçekleþen tonla varyasyondan oluþur
 ki bunlarýn temeli aslen bir kaç tane asýl süreçle ifade edilebilir" gibi
 bir kriterden bahseder.
 Tipik örneðimiz olan AddVirtualHost gibi bir sürü iþlevin, host üzerinde
 servisin çalýþtýrýlmasý ile çözülebilmesi gibi bir örnek yardýmcý olacaktýr.
 Ýlk bakýþta karýþýk olan, Virtual Host Web Servisi, SMTP Relay Kontrol,
 SMTP virtual domains vs.
 gibi bir sürü use-case varyasyonu, bir host/domain tablosu ve hepsi birbirinin
 ayný olan "service" nesnesi yoluyla çözülebilmektedir.
\layout Standard

Ýþlem sekanslarýnýn çerçevesi (scope), temel olarak "Kullaným Süreci"nde
 tarif edilen bir girdiye tekabül eder.
 Bu çerçeve yönetilemeyecek kadar geniþ olmamalýdýr.
 Diðer yandan, bir GKA yazarýnýn bu tür bir süreç tarif etmesi durumunda,
 kullanýlacak entity objects'leri kolayca tespit edebilmesi önemlidir.
 Bu yüzden Jacobsen'in aktörlere yönelik yaklaþýmý ve eventler üzerinden
 elde edilmeye çalýþýlan sekanslarýn her ikiside mümkün olduðunca sekans
 diyagramýna yansýtýlabilmelidir.
 Bu sayede kullanýcýnýn actor-based veya event-basen düþünmesi halinde modelin
 zayýf kalmasý önlenebilir.
\layout Itemize

Kullaným sürecine bakarak iþlem sekanslarýný tanýmlamak.
\begin_deeper 
\layout Itemize

Gereken iþlem sekansýný tanýmlama
\layout Itemize

Aktörler tanýmlayýp bunlarýn baþlatacaðý sekanslarý simüle etmek.
\begin_deeper 
\layout Itemize

Aktörün ana görevi nedir?
\layout Itemize

Bu aktör hangi bileþenlere eriþir?
\layout Itemize

Bu aktör nasýl bir veriyi getirebilir?
\layout Itemize

Aktör sürecin sonucundan nasýl haberdar edilebilir?
\layout Itemize

Aktör beklenmedik deðiþikliklerden nasýl haberdar edilebilir ?
\end_deeper 
\layout Itemize

Eventler üzerinden giderek sekanslar tanýmlabilir.
\begin_deeper 
\layout Itemize

Bir kabul edilecek event listesi çýkarýlýr.
\layout Itemize

Bu listeye tekabül eden iþlem sekanslarý ve sonuçlarý çýkarýrýz.
\layout Itemize

Sekanslarýn benzerliði üzerinden eventler ayýklanýr.
\layout Itemize

Bir event birden fazla sonuç çýkarabilir.
\layout Itemize

Bu durumda sonuçlarýn elde edildiði farklý ve baðýmsýz iþlem sekanslarý
 tanýmlanmýþ olmalýdýr.
 Bu durumda iþlem sekansýný yönlendiren event ile birlikte sunulan veri
 olacaktýr.
\end_deeper 
\end_deeper 
\layout Standard

Elde edilen sekanslar diagram haline getirilir.
 Sonuçta elde edilen diagram þu checklist'i karþýlamalýdýr:
\layout Itemize

Tarif edilen aktörler hiyerarþik olarak olasý tüm aktörlerin sahasýný kapsýyor
 mu?
\layout Itemize

Bu aktörler mantýksal olarak temiz þekilde tarif edilip adlandýrýlmýþlar
 mý?
\layout Itemize

Tüm iþlem sekanslarý tanýmlanmýþ mý?
\layout Itemize

Bu sekanslar kabul edilebilir seviyede sistem gerekliliklerini kapsýyor
 mu? (ortak sekanslara ulaþýnca bunlarýn doðrudan bir aktör tarafýndan tetiklenm
ediðine emin olun, ortak sekanslar baþka sekanslar için gidilecek yolun
 bir parçasý olmalýdýr).
\layout Itemize

Tüm aktörlerin bir iþlem sekansýyla eþleþtiðini onaylayýn.
\layout Itemize

Tüm ortak sekanslarýn tanýnýyor olduðunu ortaya koyun.
\layout Itemize

Bu sekanslarýn düzgün isimlendirildiðini ve aþýrý komplike olmadýðýný doðrulayýn.
\layout Itemize

Ýþlem sekansýnda belirlenen yolun exceptionlar vs.
 ile baþka yollara sapamadýðýndan emin olun.
\layout Subsection

Discovering Entity Objects
\layout Standard

Entity Objects, bu ana kadar "real-world" gözlüðünden görünen nesnelerin
 geniþletilerek elde edilen "Code-oriented" nesnelerdir.
 Bu süreçte elde edilen nesne tanýmlarý temel olarak "User View Objects"
 in açýlýmý ve iþlem sekans diyagramýndan çýkarýlan property/method listesine
 göre olacaktýr.
 Bir önceki adým olan "System Transaction Sequence Diagrams" çalýþmasý,
 OM'un gerektirdiði *fonksiyoneliteyi* dökümantize etmeyi saðlayacaktýr.
 Bu adýmda yapýlan analiz sonunda bulunan nesneler ise bu fonksiyoneliteyi
 destekleyecek yapýyý gösterecektir.
\layout Standard

Aktörler, sistemi kullanacak uygulama, kullanýcý vs.
 olarak tarif edilir.
 Ýdeal durumda, eventlerin geliþleri ardý ardýna belirli bir sekans oluþturur
 ve aktörün ne yapmak istediðine dair süreci tarif eder.
 Böylece sekans diyagramýna bakarak iþ akýþýný gösteren yol tarif edilebilir.
 Sekanslarýn gidiþ yönünde bazý alternatif yollar olmasý mümkündür.
 Bunlarýn belirlenmesi faydalý olacaktýr.
\layout Standard

Entity Objects'in belirlenmesi (bulunmasý) aþamasýnda, Candidate Objects
 için uygulanan yöntemler faydalý olabilecektir.
 Bununla birlikte, nesneleri aramak için bir kaç farklý perspektif tanýmlanabili
r:
\layout Description

Veri\SpecialChar ~
(DATA)\SpecialChar ~
Prespektifi: Pek çok uygulamada veriler sistemin baskýn karakteristiði
ni oluþtururlar.
 Verilere doðru açýdan bakýlabilirse, burada böyle bir nesne var demek daha
 kolay olacaktýr.
 Shlaer ve Mellor "bu açýdan nasýl doðru bakýlýr ?" konusunda önemli tezler
 geliþtirmiþlerdir.
 Fakat burada öngörülen, "Generic Objects / Industry Specific / Environment
 Specific" domainlerin yapilandirma sistemi acisindan cok kritik olmadigi
 gorulmektedir.
 Buna mukabil, eger yapilandirilacak uygulamalarýn (yapýlandýrma aracý deðil)
 nasýl bir "veri" iþlediðine dair elle tutulur bir taným ortaya konabilirse,
 bu verinin bir nesne olarak modellenmesi mümkün olabilir.
 Örneðin, MTA's, POP3/IMAP, MUA's vs.
 hepsi aslen "message" türünde bir veri iþleyen araçlardýr.
 Burada modelin merkezine bu veri tipi konabilir.
 Elbette "veri" basitçe "integer/string" gibi vurgulanabilen bir yapýda
 olmayacaktýr.
 Ama "veriyi" ifade eden nesnenin hayat sürecinin çýkarýlmasý, gerekli olan
 sistem nesnelerini gösterebilecektir.
\layout Description

Fonksiyonel\SpecialChar ~
Perspektif: Apple'ýn bu konuda bazý ilginç giriþimleri olmuþtur.
 Bunun sonucunda þöyle bir teori genel kabul görmüþtür.
 Öncelikle sistemin bir fonksiyonel tanýmý yapýlýr (System Transaction Sequence
 Diagrams).
 Bu taným, "iþlem sekanslarýný yerine getirmek üzere þu yapýlmalýdýr" þeklinde
 yapýlabilir.
 Ardýndan,
\layout Itemize

Ortak noktalarý (input, output...) birer nesne tarif edebilir.
\layout Itemize

Bir durum deðiþikliðine yolaçan sekansta, birden fazla veri gereksinimi
 olan noktalar.
\layout Itemize

Benzer fonksiyonelite gösteren sekans ve durumlar.
\layout Itemize

Ayný verilere gereksinimi olan noktalar.
\begin_deeper 
\layout Standard

Kabaca elde edilen nesnelerin kendilerinden beklenenleri yerine getirebilmesini
 saðlamak üzere gerekli olacaðý düþünülen attribute (property) listesi de
 benzer þekilde elde edilir.
 Attribute nesnenin nihai deðer bileþeni deðil, nesneye gerekli olan bilgileri
 ifade eder.
 Süreç þu þekilde özetlenebilir.
 Ýlgili dökümaný alýp okuyan programcý, buradaki bir cümleden bir nesne
 çýkarmaya uðraþýr.
 Burada diyelim ki, "Kedi fareyi yer" cümlesinden ilk bakýþta "noun" olan
 kediyi bir nesne olarak görme eðilimine girer.
 Bu modeli ise bunu kötü olarak ifade eder, "verb" e bakýnýz "yer" kavramýndan
 yola çýkýnýz der.
 Böylece "yemek" fiili ihtiva eden, timsah, köpek, kaplan gibi diðer cümlelerde
 ortaya çýkýnca, buradan bakýþla "Hayvan" gibi bir ana nesne veya "Aðýz,
 dil, diþler, mide vs." gibi bir sekans/hiyerarþi gösteren bir nesne veya
 nesne dizisi elde edilebilir.
 
\layout Standard

Bu perspektiften bakýþta dikkat edilmesi gereken en kritik husus, komple
 fonksiyonel bir model elde edilmesinden kaçýnýlmasýdýr.
 Bu, nesnel bir yapý yerine structural /functional bir yapý çýkarýr ve nesne
 yaklaþýmýna uydurmak zorlaþýr.
\layout Standard

Sekansýn etkilediði nesneleri geniþleterek, koda yönelik yeni nesneler (entity
 objects) elde edilir.
 Bu aþama temel nesnelerin ve buna baðlý olarak problem domain nesnelerinin
 belirlenmesini saðlar.
 Bu süreçte, Ýþlem sekanslarýna bakarak Mevcut yapýlandýrma sistemlerine
 bakarak fikir edinilebilir.
\layout Standard

Genel olarak, sisteme yeni bir nesne eklendiðine, buna baðlý bir diðer nesne
 kendini gösterecektir.
 Bu yüzden iterasyonlar doðru nesne yapýsýný çýkarmak için en geçerli yöntem
 olacaktýr.
\end_deeper 
\layout Description

Behavior\SpecialChar ~
Perspektifi: Bu bakýþ açýsýnda, kritik soru "Nesneler nasýl haberleþiyor
 ?" olmaktadýr.
 Basitçe verilen "þöyle" cevabý ise yetersiz olur.
 Burada "hangi sýklýkta, hangi þekilde, hangi cevaplarla..." gibi detaylarýnda
 bilinmesi gerekecektir.
 Burada elde edilen cevaplarýn içindeki fiil ve özneler gerekli olacak nesneler
 kadar event/mesaj modelinin çýkarýlmasýný da saðlayacaktýr.
\begin_deeper 
\layout Standard

Perspektiflerden bakýþ, her zaman her durumda en iyi olmayabilir.
 Fakat sisteme bu bakýþ açýlarýndan bakýlarak en tutarlý modelin çýkarýlmasý
 mümkün olabilir.
 Özellikle, Candidate Objects'lere bu perspektiflerin herbirinin uygulanmasý
 makul olacaktýr.
\layout Standard

Bu aþamadan sonra elde sistem gereklerini ifade eden ham bir nesne modeli
 olacaktýr.
\end_deeper 
\layout Subsection

Entity objects için structure modelini belirlemek.
\layout Standard

Bu modelden faydalanarak sisteme gerekli olan nesnelerin çýkarýlýp abstract/deta
iled nesne modelinin oluþturulmasýdýr.
 Bu durumda, nesneler arasýndaki baðlantýlar, nesnelerin sistem gereksinimleri,
 overlapped veya duplicated nesneler belirlenmiþ olur.
\layout Standard

Elde edilen Entity Object's için þu checklist kullanýlabilir:
\layout Itemize

Nesneler, temiz ve anlaþýlýr þekilde adlandýrýlmýþ, doðalarýný ifade eden
 bir kýsa taným yapýlmýþ olmalý.
\layout Itemize

"User-View Objects" üzerinde (PDC) tarif edilen nesnelerle entity nesneleri
 karþýlaþtýrýlýr.
 Bir veya bir kaç entity object bir PDC nesnesini birebir örtmelidir.
 Bir entity nesnesinin birden fazla PDC nesnesine tekabül etmesi arzu edilmez.
 Bu durumda bu sonucun ikna edici þekilde izahý gerekir.
\layout Itemize

Nesnelerin inheritance ihtiyaçlarýnýn içiçe çok fazla seviyede olmasý engellenme
lidir.
 Arzu edilen 1 seviyeli inheritance, kabul edilebilir seviye ise 2-3 aþamalý
 inheritance olabilir.
\layout Itemize

OM modeline özel olarak, bir nesnenin sadece bir tek nesneden inheritance
 alacaðý doðrulanmalýdýr.
 Herhangi bir nesne iki farklý nesneden inherit etmemelidir.
\layout Itemize

Aggregation nesneleri (kombine nesneler) tarif edilmediðinden emin olunmalýdýr.
\layout Itemize

Tek bir attribute'a (property veya method) sahip olan nesneler var mý? Bunlarýn
 aslýnda baþka bir nesnenin parçasý olmasý ihtimalini iyice incelenmelidir.
\layout Itemize

Her bir attribute için (tüm nesneler veya sub sistemi ifade eden nesne grubunda)
 tekrar eden deðerler varmý? Bunlar yeni bir nesneyi gösteriyor olabilirler.
\layout Itemize

Nesnenin tüm attribute'lerinin hayat döngüsündeki her adým için efektif
 olduðunu (iþleme girdiði) doðrulayýn.
 Aksi durum bunlarýn yeni bir nesnede toplanmasý ihtiyacýný gösterebilir.
\layout Itemize

Olasý baðýntýlarý kontrol edin.
 Many-to-Many baðýntýlardan uzak durmaya çalýþýrken, bazý baðýntýlarýn circular
 olarak nesneleri döngüye sokmayacaklarýndan emin olun.
\layout Itemize

Baðýntýlarýn temiz ve anlaþýlýr olarak adlandýrýldýklarýna emin olun.
\layout Subsection

Modelin partisyonlara ayrýlmasý
\layout Standard

Partisyonlar, modelin baðýmsýz bileþenlere ayrýlmasý sürecidir.
 Bu sayede modelin her parçasý ayrý ayrý dizayn edilebilir.
 Partisyonlar iki þekilde gerçeklenebilir.
\layout Description

Yatay\SpecialChar ~
Partisyonlar\SpecialChar ~
(Layering): Bunlar sistemin katmanlarýný çýkarýrlar.
 Tipik layer modelini sunar.
 Alttaki katman bir üsttekine hizmet eder.
 Yukarýya gidildikçe kullaným süreçlerine, aþaðýya gidildikçe sistem çaðrýlarýna
 doðru yaklaþýlýr.
 Bu model mimari dizayný çýkarýrken son derece kullanýþlý olur.
\layout Description

Dikey\SpecialChar ~
Partisyonlar\SpecialChar ~
(Partitioning): Burada sistem fonksiyonelitesi yönünden
 ayrýma gidilir.
 Bu fonksiyonelite birbirine baðýmlý olmayan bileþenleri ifade eder.
 Her partisyon kendi içinde bütünlük saðlar, diðer bileþenlere görünür bir
 baðýmlýlýðý yoktur.
 Dikey partisyonlar özellikle sistem gereklerini çýkarmada kullanýþlýdýr.
\layout Standard

OM özelinde, sistemin partitioning haline çekilmesi anlamsýzdýr.
 Fakat, OM'un dizayný yapýlýrken bu husus gözönüne alýnmalýdýr.
 Bilhassa belli bir fonksiyonelite grubunun layerler halinde nesneye dökülmesi
 kritiktir.
 Böylece üst katmanlarda kalanlarýn alt katmanlardaki nesneleri gerçekten
 verimli kullanabilmeleri mümkün olabilir.
 Partitioning ise alt sistem bazýnda doðal olarak yerine getirilmektedir.
\layout Section

Genel olarak OO Dizayn Kýlavuzu
\layout Standard

McMenamin, Palmer, Booch, Jacobsen, Yourdon gibi OOP gurularýnýn bilhassa
 satýr aralarýnda sunduðu bazý püf noktalarýndan derlenen aþaðýdaki bilgiler
 iyi bir nesne modeli dizayn etmek üzere faydalý olacaktýr:
\layout Description

Information\SpecialChar ~
Hiding: Nesnenin içerdiði tüm verilere, nesneyi kullananlar tarafýnda
n kesinlikle ulaþýlamamalýdýr.
\layout Description

Demeter\SpecialChar ~
Kanunu: Bu kural Lieberherr tarafýndan ortaya konmuþtur.
 Kural, bir nesnenin hangi nesneleri çaðýrabileceðini tarif eder.
 Burada "A" nesnesinin "m" methodundan sadece þu kurallara uyan çaðrýlar
 yapýlabilir:
\begin_deeper 
\layout Itemize

m'e parametre olarak geçirilecek olan herhangi bir nesneyi.
\layout Itemize

Kendi nesnesindeki diðer method/property'leri
\layout Itemize

Yapýsý mutlak olarak bilinen diðer nesneleri.
\layout Itemize

m metodu içinde oluþturulan nesneleri.
\layout Itemize

Global deðiþken olarak tarif edilen nesneleri.
\end_deeper 
\layout Standard


\begin_inset Graphics
	filename meren.png
	rotateOrigin center

\end_inset 


\layout Standard

Yukarýdaki þekilde, B ve C tarif edilmiþ nesnelerdir.
 B1 ve C1 ise sadece B ve C tarafýndan bilinen nesnelerdir.
 Demeter kanunu, implementationlarý yapacak olan kullanýcý tarafýndan bilinemeye
bilir.
 Bu nedenle, nesneleri iþletecek ortamýn bu kanuna uymayý zorlamasý gerekmektedi
r.
 Bu kural, bilgiyi gizleme ve yerelleþtirme (localization) kabiliyetini
 artýran, iþlem karmaþýklýðýný ve çevrimsel çaðrýlarý (nested messages)
 azaltan bir prensip olarak kabul görülmektedir.
 Buna mukabil, operasyon sayýsý ile metodlara gereken parametre sayýsýný
 artýrma gibi bir dezavantaja sahiptir.
 Prensip olarak, durumlarý iyi belirlenmiþ olan nesneler arasýnda direk
 çaðrýlar yapýlmasý makul olabilir.
 Fakat bu durumun ikna edici þekilde dökümantize edilmesi gereklidir.
\layout Description

Ortak\SpecialChar ~
Kod\SpecialChar ~
Üretimini\SpecialChar ~
Dýþlamak: Bir nesnenin alt nesneleri tarafýndan paylaþýlmasý
 ihtimali olan kodlarýn abstract olarak býrakýlmayarak, altnesnelerden yapýlacak
 çaðrýlarýn bulanýk olmasý engellenmelidir.
 Kýsaca, A nesnesinden türeyen B ve C nesnelerinin kendilerine göre birer
 "C.A.m" ve "B.A.m" metodu implement etmeleri engellenmeli, A nesnesi "m" kodunu
 mutlak ihtiva etmelidir.
\layout Description

"Implementation\SpecialChar ~
Inheritance"\SpecialChar ~
Engellenmelidir: Eðer bir nesne bir diðerindeki
 uyarlamayý (implementation) bir parçasý olarak kullanmak istiyorsa, o nesneden
 türemek (inherit) yerine o nesneyi kapsayan bir "aggregation" veya "delegation"
 kullanmayý tercih etmelidir.
 Örnek olarak elimizde bir "list" nesnesi olsun.
 "first, last, add, delete" metotlarý list'in metotlarý olsun.
 Bu nesneden bir "stack" nesnesi türetirsek, gereksiz olan "first/last"
 metodlarý yeni nesne içersinde de olacaktýr.
 Bu metodlarýn doðrudan açýk olmasý encapsulation'u zedeleyecektir.
 Bunun yerine stack nesnesinin içeriðinde bulunacak olan bir List elemaný,
 bunlarý güzelce kapsülleyecektir.
\layout Description

Dizaynýn\SpecialChar ~
Temizliðine\SpecialChar ~
Odaklanýlmasý: Nesne/method/property Ýsimlerinde yanlýþ
 anlaþýlma veya farklý anlamlar çýkarýlmasý engellenmeli; nesnelerin ifade
 ettiði görevlerin bulanýk olmamasý gözetilmeli ve nesneler arasý iletiþimde
 bulanýk protokoller kullanýlmamalýdýr.
\layout Standard

Bu prensiplerin akýlda tutulmasý, nesne modelinin daha saðlýklý olmasýný
 kolaylaþtýracaktýr.
 Ayrýca nesneleri iþletecek olan uygulamanýn bu prensipleri kontrol edebilecek
 mekanizmalara sahip olmasý faydalý olacaktýr.
\the_end

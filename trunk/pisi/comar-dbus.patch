Index: comariface.py
===================================================================
--- comariface.py	(revision 16699)
+++ comariface.py	(working copy)
@@ -25,117 +25,126 @@
     pass
 
 try:
-    import comar
+    import dbus
 except ImportError:
-    raise Error(_("comar package is not fully installed"))
+    raise Error(_("dbus-python package is not fully installed"))
 
-def get_comar():
-    """Connect to the comar daemon and return the handle"""
+def is_char_valid(char):
+    """Test if char is valid object path character."""
+    char = ord(char)
+    return (char in xrange(65, 91) or
+           char in xrange(97, 123) or
+           char in xrange(48, 58) or
+           char == '_')
+
+def make_object_path(package):
+    """Generates DBus object name from package name."""
+    object = package
+    for char in package:
+        if not is_char_valid(char):
+            object = object.replace(char, '_')
+    return object
+
+def get_iface(package="", model=""):
+    """Connect to the DBus daemon and return the system interface."""
     
+    """
     sockname = "/var/run/comar.socket"
     # YALI starts comar chrooted in the install target, but uses PiSi outside of
     # the chroot environment, so PiSi needs to use a different socket path to be
     # able to connect true comar (usually /mnt/target/var/run/comar.socket).
     if ctx.comar_sockname:
         sockname = ctx.comar_sockname
+    """
     
+    if package:
+        obj_path = "/package/%s" % package
+    else:
+        obj_path = "/"
+    if model:
+        obj_interface = "tr.org.pardus.comar.%s" % model
+    else:
+        obj_interface = "tr.org.pardus.comar"
+    
     # This function is sometimes called when comar has recently started
     # or restarting after an update. So we give comar a chance to become
     # active in a reasonable time.
     timeout = 7
     while timeout > 0:
         try:
-            com = comar.Link(sockname)
-            return com
-        except comar.CannotConnect:
+            bus = dbus.SystemBus()
+            obj = bus.get_object("tr.org.pardus.comar", obj_path)
+            iface = dbus.Interface(obj, dbus_interface=obj_interface)
+            return iface
+        except dbus.DBusException:
             pass
         time.sleep(0.2)
         timeout -= 0.2
-    raise Error(_("cannot connect to comar"))
+    raise Error(_("cannot connect to dbus"))
 
-def wait_for_result(com, package_name=None):
-    multiple = False
-    while True:
-        try:
-            reply = com.read_cmd()
-        except select.error:
-            if ctx.keyboard_interrupt_pending():
-                return
-            raise
-        except comar.LinkClosed:
-            # Comar postInstall does a "service comar restart" which cuts
-            # our precious communication link, so we waitsss
-            if package_name == "comar":
-                try:
-                    get_comar()
-                except Error:
-                    raise Error, _("Could not restart comar")
-                return
-            else:
-                if ctx.keyboard_interrupt_pending():
-                    return
-                raise Error, _("connection with comar unexpectedly closed")
-        
-        cmd = reply[0]
-        if cmd == com.RESULT and not multiple:
-            return
-        elif cmd == com.NONE and not multiple:
-            # no post/pre function, that is ok
-            return
-        elif cmd == com.RESULT_START:
-            multiple = True
-        elif cmd == com.RESULT_END:
-            return
-        elif cmd == com.FAIL:
-            raise Error, _("Configuration error: %s") % reply[2]
-        elif cmd == com.ERROR:
-            raise Error, _("Script error: %s") % reply[2]
-        elif cmd == com.DENIED:
-            raise Error, _("comar denied our access")
-
 def post_install(package_name, provided_scripts, scriptpath, metapath, filepath, fromVersion, fromRelease, toVersion, toRelease):
     """Do package's post install operations"""
     
     ctx.ui.info(_("Configuring %s package") % package_name)
     self_post = False
-    com = get_comar()
+    sys_iface = get_iface()
+    object_name = make_object_path(package_name)
     
     for script in provided_scripts:
         ctx.ui.debug(_("Registering %s comar script") % script.om)
         if script.om == "System.Package":
             self_post = True
-        com.register(script.om, package_name, os.path.join(scriptpath, script.script))
-        wait_for_result(com)
+        try:
+            sys_iface.register(object_name, script.om, os.path.join(scriptpath, script.script))
+        except dbus.DBusException, exception:
+            raise Error, _("Script error: %s") % exception
     
     ctx.ui.debug(_("Calling post install handlers"))
-    com.call("System.PackageHandler.setupPackage", [ "metapath", metapath, "filepath", filepath ])
-    wait_for_result(com)
+    for handler in sys_iface.listModelApplications("System.PackageHandler"):
+        iface = get_iface(handler, "System.PackageHandler")
+        try:
+            iface.setupPackage(metapath, filepath)
+        except dbus.DBusException, exception:
+            raise Error, _("Script error: %s") % exception
     
     if self_post:
-        args = {
-            "fromVersion": fromVersion,
-            "fromRelease": fromRelease,
-            "toVersion": toVersion,
-            "toRelease": toRelease,
-        }
+        if not fromVersion:
+            fromVersion = ""
+        if not fromRelease:
+            fromRelease = ""
+        
         ctx.ui.debug(_("Running package's post install script"))
-        com.call_package("System.Package.postInstall", package_name, args)
-        wait_for_result(com, package_name)
+        try:
+            iface = get_iface(object_name, "System.Package")
+            iface.postInstall(fromVersion, fromRelease, toVersion, toRelease)
+        except dbus.DBusException, exception:
+            raise Error, _("Script error: %s") % exception
 
 def pre_remove(package_name, metapath, filepath):
     """Do package's pre removal operations"""
     
     ctx.ui.info(_("Configuring %s package for removal") % package_name)
-    com = get_comar()
+    sys_iface = get_iface()
+    object_name = make_object_path(package_name)
     
-    ctx.ui.debug(_("Running package's pre remove script"))
-    com.call_package("System.Package.preRemove", package_name)
-    wait_for_result(com)
+    if "System.Package" in sys_iface.listApplicationModels(object_name):
+        ctx.ui.debug(_("Running package's pre remove script"))
+        iface = get_iface(handler_application, "System.PackageHandler")
+        try:
+            iface.preRemove()
+        except dbus.DBusException, exception:
+            raise Error, _("Script error: %s") % exception
     
     ctx.ui.debug(_("Calling pre remove handlers"))
-    com.call("System.PackageHandler.cleanupPackage", [ "metapath", metapath, "filepath", filepath ])
-    wait_for_result(com)
+    for handler in sys_iface.listModelApplications("System.PackageHandler"):
+        iface = get_iface(handler, "System.PackageHandler")
+        try:
+            iface.cleanupPackage(metapath, filepath)
+        except dbus.DBusException, exception:
+            raise Error, _("Script error: %s") % exception
     
     ctx.ui.debug(_("Unregistering comar scripts"))
-    com.remove(package_name)
-    wait_for_result(com)
+    try:
+        sys_iface.remove(object_name)
+    except dbus.DBusException, exception:
+        raise Error, _("Script error: %s") % exception
Index: atomicoperations.py
===================================================================
--- atomicoperations.py	(revision 16699)
+++ atomicoperations.py	(working copy)
@@ -146,7 +146,7 @@
         # check comar
         if self.metadata.package.providesComar and ctx.comar:
             import pisi.comariface as comariface
-            comariface.get_comar()
+            comariface.get_iface()
 
     def check_relations(self):
         # check dependencies

<?xml version="1.0" encoding="utf-8" standalone="no"?>

<!DOCTYPE book SYSTEM "http://www.uludag.org.tr/style/uludagbook.dtd"
[
  <!ENTITY projectname "COMAR">
  <!ENTITY longname "Configuration by Objects: Modify And Restart">
]>


<book version="0.1" lang="tr" type="guide">

  <bookinfo>
    <title>&projectname;</title>
    <subtitle>&longname;</subtitle>

    <author author_id="2">
      <firstname>Barış</firstname>
      <lastname>Metin</lastname>
      <address>
        <email>baris@uludag.org.tr</email>
      </address>
    </author>

    <author author_id="2">
      <firstname>Erkan</firstname>
      <lastname>Tekman</lastname>
      <address>
        <email>tekman@uludag.org.tr</email>
      </address>
    </author>

    <pubdate>2004-03-08</pubdate>
    <revhistory>
      <revision author_id="1">
        <revnumber>0.1</revnumber>
	<date>2004-03-05</date>
      </revision>
    </revhistory>

    <abstract>
      <para>
         &projectname;, is a configuration framework designed essentially for Linux systems. This configuration framework will function as a middle layer between configuration tools, package management system and other frameworks.
      </para>
    </abstract>
  </bookinfo>

  <chapter>
    <chapterinfo>
      <title>Why a "Configuration Framework"?</title>
      <abstract>
         <para>Do we really need a configuration framework? What are the problems of the present task-based configuration processes, possible solutions.
         </para>
      </abstract>
    </chapterinfo>

    <sect1>
      <title>What a Configuration Framework does?</title>
      <para>
        The configuration framework could be basically thought as an <strong>abstraction layer</strong> between the <em>configuration tools</em> and the <em>configuration processes</em>.
      </para>
      <para>
        The configuration process in Linux/Unix world generally consists of;
        <orderedlist>
          <listitem>Modify the configuration file</listitem>
          <listitem>If some other service/system required to be configured for this configuration to work properly, carry out that one as well</listitem>
          <listitem>Restart the reconfigured services/systems if necessary</listitem>
        </orderedlist>
        steps.
      </para>
      <para>
	Consequently, the system managers (<em>eventually the desktop users</em>) need a nice text editor for executing the configuration process. This is inevitable since the system components that have to be operated together are not aware of each other.
      </para>
      <para>
	Seemingly acceptable for <em>experienced users</em>, and also flexible and even ideal for some; still for some users who only wants to use the system this process is highly painstaking. The system manager has to know about the whole of the system in order to apply a configuration change to a minor part.
      </para>
      <para>
	One of the reasons for the (generally acclaimed) steep learning curve for Linux/Unix systems is the level of proficiency required to carry out the configuration (or customization according to the personal needs) process.
      </para>
      <para>
	In this respect it is clear that the configuration framework has to be an abstraction layer that hides this complexity of te system from the user. The user rightfully want o have the tasks done <em>magically</em> when s/he enters a command or hits a button.
      </para>
    </sect1>

    <sect1>
      <title>Present and possible solutions!</title>
      <para>
	The trivial and practical way of hiding the discrepancy in the configuration process (the system components being unaware of each other) from the system user is employing a graphical/text/web-based interface for the user.
      </para>
      <para>
      All of the present methods built the configuration tools using this <em>simple (!)</em> method. The configuration tools may be discrete (redhat-config-*), integrated (Mandrake Control Center, YaST) or web-based (webmin), still all of them use the same principle to hide the complexity from the user.
      </para>
      <para>
      The problem here is making the configuration tools too clever <em>independently</em> and placing them in a chaos (instead of performing vast capabilities).
      </para>
      <para>
      Another solution is to have all the systems configure themselves appropriately when they are first installed. This brings you to a crossroads: You have to select between two methods, which have some problems intrinsically.
       <orderedlist>
         <listitem>You either have to carry out the configuration according to some default values, and leave the more flexible configuration choices for the configuration tools, which brings you to the earlier described problem.
	 </listitem>
         <listitem>Or you will carry out the installation interactively  (Debian/Debconf) to make installation process harder.</listitem>
       </orderedlist>
     </para>
     <para>
     Both methods makes packages and the package management system more complex.
     </para>
     <para>
     The ideal solution that pops into one's mind is to <strong>develop the components that you add to the system as parts of a coherent whole</strong>. This way all software will be developed according to the framework that we set. This provides an <em>identical</em> configuration process for all the system components, and configuration tools have not to be deal with each component separately, and even a single point of configuration may suffice. It only requires a configuration management framework to define this single point of contact.
     </para>
     <para>
	Still this last choice is not <strong>suitable</strong> for the free software culture that we are operating. Having a single point of control for free software is not only possible, it is not preferable. Similar <em>standardization</em> efforts are being carried out by independent organizations. Freedesktop is working on determining the standards ffor desktop environments, but there is not a similar initiative for a system-wide. Even if there has been such a standard, the 100% compliance with the standards would require time.
     </para>
    </sect1>

  </chapter>

  <chapter>
     <chapterinfo>
       <title>Solution proposal by Uludag: &projectname;</title>
       <abstract>
         <para><graphic source="/img/comar/comar.png" align="bottom"/> &projectname; (&longname;) is the <strong>abstraction layer</strong> framework that we propose. The main task of the abstraction layer is to hide the system-wide complexity from the configuration tools. Such an abstraction may even provide new capabilities to the configuration tools.</para>
       </abstract>
     </chapterinfo>

     <sect1>
       <title>Design</title>
       <para>
         We will describe the design by going over a sample scenario in figures.
       </para>
       <para>
         <graphic source="/img/comar/VH1_present.png" align="bottom"/>
       </para>
       <para>
       The first figure is the classical configuration process. A text editor is used to modify the configuration file and the service is warned about the reconfiguration. We just summarize the classical method in this figure.
       </para>
       <para>
       We now try to visualize the configuration process for which &projectname; is active:
       </para>
       <para>
         <graphic source="/img/comar/VH2_request.png" align="bottom"/>
       </para>
       <para>
         The configuration tool (the <em>GUI</em> in the figure) releases the configuration request to the &projectname; core through the &projectname;-API  which is denoted as <em>interface</em>. <strong>The communication here and elsewhere may be via <em>requests/replies</em> embedded in an object, or through a predefined protocol.</strong>
       </para>
       <para>
         <graphic source="/img/comar/VH3_search.png" align="bottom"/>
       </para>
       <para>
         &projectname; core contacts the configuration storage to get the system-wide information.
         <orderedlist>
           <listitem>Do I have the necessary information for the requested configuration?</listitem>
           <listitem>Who is responsible of this configuration?</listitem>
           <listitem>What else do I need?</listitem>
         </orderedlist>
       </para>
       <para>
         <graphic source="/img/comar/VH4_objects.png" align="bottom"/>
       </para>
       <para>
         &projectname; core finds the relevant objects from the object pool and gets the necessary information. Here it communicates with the  <em>webserver</em> object and is directed to the <em>apache</em> object., and necessary info is gathered from the <em>apache</em> object.
       </para>
       <para>
         <graphic source="/img/comar/VH5_configure.png" align="bottom"/>
       </para>
       <para>
         The configuration storage is updated using the information gathered from the <em>apache</em> object.
       </para>
       <para>
         <graphic source="/img/comar/VH6_objects2.png" align="bottom"/>
       </para>
       <para>
         The other object necessary for the configuration is the <em>nameserver</em> object. It is contacted similarly to point out the <em>DNS (Bind)</em> object.
       </para>
       <para>
         <graphic source="/img/comar/VH7_configure2.png" align="bottom"/>
       </para>
       <para>
         The process for the <em>apache</em> example repeated in case the <em>DNS</em> service is also local. If (as seen in figure) it is not a local service, the domain name records that have to updated are modified by a Remote Procedure Call (RPC) in accord with the information gathered from the <em>DNS</em> object.
       </para>
       <para>
         <graphic source="/img/comar/VH8_parsestore.png" align="bottom"/>
       </para>
       <para>
	The configuration updates are taken from the configuration storage and using <em>conf parser</em> stored into the <em>apache</em> configuration file(s).
       </para>
       <para>
         <graphic source="/img/comar/VH9_restart.png" align="bottom"/>
       </para>
       <para>
         The apache service is warned to activate the change.
       </para>

     </sect1>
     <sect1>
       <title>This Design Provides</title>
       <para>
         Let us try to enumerate the contribution of this design.
         <orderedlist>
           <listitem>The configuration tools have not to deal with the complexity of the system, thanks to the abstraction.</listitem>
           <listitem>It will be easier to manage to configuration choices, which are held in the configuration storage in a structured way. It becomes very easy to use them in other services, transferring or copying them, or releasing them to other machines on the network.</listitem>
           <listitem>The configuration choices may be stored locally, or in a remote storage area. &projectname; Config may get some configuration choices from the local, and the network-wide configuration from a remote location.</listitem>
         </orderedlist>
       </para>
     </sect1>

 </chapter>

	   
</book>
